Agent Prompt: Gap #8 - Proxies & Custom HTTP Clients

Task Overview

You are implementing proxy support and custom HTTP client injection for Tinkex, an Elixir port of the Tinker Python SDK. The Python SDK exposes proxy support through user-supplied `httpx.AsyncClient`
instances (proxies/transport/limits). The Elixir SDK currently has NO proxy support and limited HTTP client customization, wiring all traffic through a single Finch pool (`Tinkex.HTTP.Pool`) started at
application boot (callers can only point at another pool if they start it themselves).

This gap is critical for enterprise adoption as many organizations require proxy support for all outbound HTTP traffic.

Required Reading

Read these files in order before implementation:

Gap Analysis Document:
- ./docs/20251127/gaps_06/08_proxies_http_clients.md

Python Reference Implementation:
- ./tinker/src/tinker/_client.py - AsyncTinker class accepting http_client parameter
- ./tinker/src/tinker/_base_client.py - AsyncAPIClient, DefaultAsyncHttpxClient, timeout inheritance logic
- ./tinker/src/tinker/_types.py - ProxiesDict, ProxiesTypes type definitions
- ./tinker/src/tinker/_constants.py - DEFAULT_TIMEOUT, DEFAULT_CONNECTION_LIMITS

Elixir Current Implementation:
- ./lib/tinkex/config.ex - Current config struct (no proxy field; `http_pool` is just a pool name)
- ./lib/tinkex/env.ex - Environment variable handling (no HTTP_PROXY/HTTPS_PROXY helpers)
- ./lib/tinkex/http_client.ex - Minimal behaviour (only 3 callbacks, no state)
- ./lib/tinkex/api/api.ex - Direct Finch usage, no client injection point
- ./lib/tinkex/application.ex - Starts a single Finch pool (`Tinkex.HTTP.Pool`) with env/app sizing

Gap Explanation

Python HTTP Client Architecture:

# Python SDK allows full HTTP client injection
class AsyncTinker(AsyncAPIClient):
    def __init__(
        self,
        *,
        api_key: str | None = None,
        http_client: httpx.AsyncClient | None = None,  # Full customization
        # ...
    ) -> None:
        super().__init__(
            http_client=http_client,  # Passed through
            # ...
        )

# Proxy usage flows through the `http_client` you pass (configure `httpx.AsyncClient(proxies=...)`).

Proxy Configuration Examples in Python:

# Simple HTTP proxy
client = AsyncTinker(
    api_key="...",
    http_client=httpx.AsyncClient(
        proxies="http://proxy.example.com:8080"
    )
)

# Proxy with authentication
client = AsyncTinker(
    api_key="...",
    http_client=httpx.AsyncClient(
        proxies=httpx.Proxy(
            url="http://proxy.example.com:8080",
            auth=("username", "password")
        )
    )
)

# Per-protocol proxies
client = AsyncTinker(
    api_key="...",
    http_client=httpx.AsyncClient(
        proxies={
            "http://": "http://proxy1.example.com:8080",
            "https://": "https://proxy2.example.com:8443"
        }
    )
)

Elixir Current Problems:

1. No proxy configuration in Tinkex.Config:
# config.ex - No proxy field
defstruct [
:base_url,
:api_key,
:http_pool,        # Just a pool NAME, not customization
:timeout,
# ... no :proxy field
]
2. No HTTP_PROXY environment support in Tinkex.Env:
# env.ex - Missing proxy env vars
def snapshot(env \\ :system) do
%{
    api_key: api_key(env),
    base_url: base_url(env),
    # ... no http_proxy or https_proxy
}
end
3. Direct Finch usage without proxy options:
# api.ex - No proxy passed to Finch.build
request = Finch.build(:post, url, headers, body)  # Missing proxy option!
Finch.request(request, config.http_pool, receive_timeout: timeout)
4. Minimal HTTPClient behaviour - no state, no initialization:
# Current behaviour is stateless, can't hold client config
@callback post(path :: String.t(), body :: map(), opts :: keyword()) ::
            {:ok, map()} | {:error, Error.t()}
5. Pool routing is effectively global: only `Tinkex.HTTP.Pool` is started and `pool_key`/`pool_type`
   are computed but not used to pick a different Finch pool.

Finch DOES Support Proxies - They just aren't exposed in Tinkex:
# Finch's proxy support (not currently used)
Finch.build(:get, url, headers, body,
proxy: {:http, "proxy.example.com", 8080, [username: "user", password: "pass"]}
)

Implementation Requirements

Phase 1: Proxy Configuration in Config

1.1 Add proxy types and field to Tinkex.Config (./lib/tinkex/config.ex):

defmodule Tinkex.Config do
@enforce_keys [:base_url, :api_key]
defstruct [
    :base_url,
    :api_key,
    :http_pool,
    :proxy,           # NEW: Proxy configuration
    :timeout,
    :max_retries,
    # ... rest unchanged
]

@type proxy_opt ::
    String.t() |                                          # "http://proxy:8080"
    {:http, String.t(), pos_integer(), keyword()} |      # HTTP proxy tuple
    {:https, String.t(), pos_integer(), keyword()} |     # HTTPS CONNECT proxy
    nil                                                   # No proxy

@type t :: %__MODULE__{
    base_url: String.t(),
    api_key: String.t(),
    http_pool: atom(),
    proxy: proxy_opt(),
    # ... rest unchanged
}
end

1.2 Add proxy parsing to Config.new/1:

def new(opts \\ []) do
env = Env.snapshot()

# ... existing code ...

proxy = parse_proxy_option(opts, env)

%__MODULE__{
    # ... existing fields ...
    proxy: proxy,
}
|> validate!()
end

defp parse_proxy_option(opts, env) do
case pick([opts[:proxy], env.http_proxy, env.https_proxy]) do
    nil -> nil
    url when is_binary(url) -> parse_proxy_url(url)
    tuple when is_tuple(tuple) -> validate_proxy_tuple(tuple)
end
end

defp parse_proxy_url(url) do
uri = URI.parse(url)

unless uri.scheme in ["http", "https"] do
    raise ArgumentError, "Proxy URL must use http:// or https:// scheme, got: #{url}"
end

unless uri.host do
    raise ArgumentError, "Invalid proxy URL: missing host in #{url}"
end

port = uri.port || default_proxy_port(uri.scheme)
opts = parse_proxy_auth(uri.userinfo)

{String.to_atom(uri.scheme), uri.host, port, opts}
end

1.3 Add environment variable support to Tinkex.Env (./lib/tinkex/env.ex):

def snapshot(env \\ :system) do
%{
    # ... existing fields ...
    http_proxy: http_proxy(env),
    https_proxy: https_proxy(env),
}
end

@spec http_proxy(env_source()) :: String.t() | nil
def http_proxy(env \\ :system),
  do: env |> fetch("HTTP_PROXY") |> normalize()

@spec https_proxy(env_source()) :: String.t() | nil
def https_proxy(env \\ :system),
  do: env |> fetch("HTTPS_PROXY") |> normalize()

# Prefer Env helpers over direct System.get_env/1 so redaction/normalization stay centralized.

Phase 2: Pass Proxy to Finch Requests

2.1 Update Tinkex.API.post/3 and get/2 (./lib/tinkex/api/api.ex):

def post(path, body, opts) do
config = Keyword.fetch!(opts, :config)

url = build_url(config.base_url, path)
timeout = Keyword.get(opts, :timeout, config.timeout)
headers = build_headers(:post, config, opts, timeout)

# NEW: Build request with proxy
request = build_finch_request(:post, url, headers, prepare_body(body, transform_opts), config.proxy)

# ... rest unchanged
end

# NEW: Build Finch request with optional proxy
defp build_finch_request(method, url, headers, body, nil) do
Finch.build(method, url, headers, body)
end

defp build_finch_request(method, url, headers, body, {proxy_type, host, port, opts}) do
Finch.build(method, url, headers, body,
    proxy: {proxy_type, String.to_charlist(host), port, finch_proxy_opts(opts)}
)
end

defp finch_proxy_opts(opts) do
opts
|> Keyword.take([:username, :password])
|> Enum.map(fn
    {:username, v} -> {:username, String.to_charlist(v)}
    {:password, v} -> {:password, String.to_charlist(v)}
end)
end

Phase 3: Enhanced HTTPClient Behaviour

3.1 Expand Tinkex.HTTPClient behaviour (./lib/tinkex/http_client.ex):

defmodule Tinkex.HTTPClient do
@moduledoc """
Behaviour for HTTP client implementations.

Allows injecting custom HTTP clients for testing, proxying,
middleware, metrics collection, etc.
"""

alias Tinkex.Error

@type state :: any()
@type headers :: [{String.t(), String.t()}]
@type body :: iodata() | nil
@type response :: %{
    status: pos_integer(),
    headers: headers(),
    body: binary()
}

@doc """
Initialize the HTTP client with configuration.
Returns `{:ok, state}` where state is passed to all requests.
"""
@callback init(config :: Tinkex.Config.t()) :: {:ok, state()} | {:error, term()}

@doc """
Make an HTTP request.
Returns `{:ok, response, new_state}` or `{:error, error, new_state}`.
"""
@callback request(
    method :: :get | :post | :put | :delete | :patch,
    url :: String.t(),
    headers :: headers(),
    body :: body(),
    state :: state()
) :: {:ok, response(), state()} | {:error, Error.t(), state()}

@doc """
Close the HTTP client and clean up resources.
"""
@callback close(state :: state()) :: :ok

@optional_callbacks [close: 1]
end

3.2 Create default Finch client implementation (./lib/tinkex/http_client/finch_client.ex):

defmodule Tinkex.HTTPClient.FinchClient do
@moduledoc """
Default HTTP client implementation using Finch.
"""

@behaviour Tinkex.HTTPClient

defstruct [:config, :pool]

@impl true
def init(%Tinkex.Config{} = config) do
    {:ok, %__MODULE__{config: config, pool: config.http_pool}}
end

@impl true
def request(method, url, headers, body, %__MODULE__{} = state) do
    request = build_request(method, url, headers, body, state.config.proxy)

    case Finch.request(request, state.pool, receive_timeout: state.config.timeout) do
    {:ok, %Finch.Response{} = response} ->
        {:ok, convert_response(response), state}
    {:error, exception} ->
        {:error, Tinkex.Error.from_exception(exception), state}
    end
end

defp build_request(method, url, headers, body, nil) do
    Finch.build(method, url, headers, body)
end

defp build_request(method, url, headers, body, {proxy_type, host, port, opts}) do
    Finch.build(method, url, headers, body,
    proxy: {proxy_type, String.to_charlist(host), port, to_charlist_opts(opts)}
    )
end

defp to_charlist_opts(opts) do
    Enum.map(opts, fn {k, v} when is_binary(v) -> {k, String.to_charlist(v)} end)
end

defp convert_response(%Finch.Response{status: status, headers: headers, body: body}) do
    %{status: status, headers: headers, body: body}
end
end

3.3 Add :http_client option to Config for custom client injection:

# In config.ex
defstruct [
# ... existing fields ...
:http_client,  # NEW: Custom HTTP client module
]

@type t :: %__MODULE__{
# ... existing fields ...
http_client: module() | nil,
}

TDD Implementation Plan

Test File: test/tinkex/config_proxy_test.exs

defmodule Tinkex.ConfigProxyTest do
use ExUnit.Case, async: true

alias Tinkex.Config

describe "proxy configuration - URL string" do
    test "parses HTTP proxy URL" do
    config = Config.new(
        api_key: "test-key",
        proxy: "http://proxy.example.com:8080"
    )

    assert config.proxy == {:http, "proxy.example.com", 8080, []}
    end

    test "parses HTTPS proxy URL" do
    config = Config.new(
        api_key: "test-key",
        proxy: "https://secure-proxy.example.com:8443"
    )

    assert config.proxy == {:https, "secure-proxy.example.com", 8443, []}
    end

    test "parses proxy URL with authentication" do
    config = Config.new(
        api_key: "test-key",
        proxy: "http://user:pass@proxy.example.com:8080"
    )

    assert {:http, "proxy.example.com", 8080, opts} = config.proxy
    assert Keyword.get(opts, :username) == "user"
    assert Keyword.get(opts, :password) == "pass"
    end

    test "uses default port 8080 for HTTP proxy without port" do
    config = Config.new(
        api_key: "test-key",
        proxy: "http://proxy.example.com"
    )

    assert {:http, "proxy.example.com", 8080, []} = config.proxy
    end

    test "uses default port 8443 for HTTPS proxy without port" do
    config = Config.new(
        api_key: "test-key",
        proxy: "https://proxy.example.com"
    )

    assert {:https, "proxy.example.com", 8443, []} = config.proxy
    end

    test "raises for invalid proxy URL scheme" do
    assert_raise ArgumentError, ~r/must use http:\/\/ or https:\/\//, fn ->
        Config.new(api_key: "test-key", proxy: "socks5://proxy.example.com:1080")
    end
    end

    test "raises for malformed proxy URL" do
    assert_raise ArgumentError, ~r/missing host/, fn ->
        Config.new(api_key: "test-key", proxy: "http://")
    end
    end
end

describe "proxy configuration - tuple" do
    test "accepts valid HTTP proxy tuple" do
    config = Config.new(
        api_key: "test-key",
        proxy: {:http, "proxy.example.com", 8080, []}
    )

    assert config.proxy == {:http, "proxy.example.com", 8080, []}
    end

    test "accepts proxy tuple with auth options" do
    config = Config.new(
        api_key: "test-key",
        proxy: {:http, "proxy.example.com", 8080, username: "user", password: "secret"}
    )

    assert {:http, "proxy.example.com", 8080, opts} = config.proxy
    assert opts[:username] == "user"
    assert opts[:password] == "secret"
    end

    test "raises for invalid proxy tuple type" do
    assert_raise ArgumentError, ~r/Invalid proxy tuple/, fn ->
        Config.new(api_key: "test-key", proxy: {:ftp, "proxy.example.com", 8080, []})
    end
    end

    test "raises for invalid port in proxy tuple" do
    assert_raise ArgumentError, ~r/port must be 1-65535/, fn ->
        Config.new(api_key: "test-key", proxy: {:http, "proxy.example.com", 0, []})
    end

    assert_raise ArgumentError, ~r/port must be 1-65535/, fn ->
        Config.new(api_key: "test-key", proxy: {:http, "proxy.example.com", 70000, []})
    end
    end
end

describe "proxy configuration - nil" do
    test "defaults to nil proxy" do
    config = Config.new(api_key: "test-key")

    assert is_nil(config.proxy)
    end

    test "accepts explicit nil proxy" do
    config = Config.new(api_key: "test-key", proxy: nil)

    assert is_nil(config.proxy)
    end
end
end

Test File: test/tinkex/env_proxy_test.exs

defmodule Tinkex.EnvProxyTest do
use ExUnit.Case, async: true

alias Tinkex.Env

describe "http_proxy/1" do
    test "reads HTTP_PROXY environment variable" do
    env = %{"HTTP_PROXY" => "http://proxy.example.com:8080"}

    assert Env.http_proxy(env) == "http://proxy.example.com:8080"
    end

    test "returns nil when not set" do
    assert is_nil(Env.http_proxy(%{}))
    end
end

describe "https_proxy/1" do
    test "reads HTTPS_PROXY environment variable" do
    env = %{"HTTPS_PROXY" => "https://secure-proxy.example.com:8443"}

    assert Env.https_proxy(env) == "https://secure-proxy.example.com:8443"
    end
end

describe "snapshot/1 includes proxy" do
    test "includes http_proxy in snapshot" do
    env = %{"HTTP_PROXY" => "http://proxy.example.com:8080"}
    snapshot = Env.snapshot(env)

    assert snapshot.http_proxy == "http://proxy.example.com:8080"
    end

    test "includes https_proxy in snapshot" do
    env = %{"HTTPS_PROXY" => "https://secure-proxy.example.com:8443"}
    snapshot = Env.snapshot(env)

    assert snapshot.https_proxy == "https://secure-proxy.example.com:8443"
    end
end
end

Test File: test/tinkex/config_env_proxy_integration_test.exs

defmodule Tinkex.ConfigEnvProxyIntegrationTest do
use ExUnit.Case, async: false

alias Tinkex.Config

setup do
    # Clean up env vars after each test
    on_exit(fn ->
    System.delete_env("HTTP_PROXY")
    System.delete_env("HTTPS_PROXY")
    end)

    :ok
end

describe "Config reads proxy from environment" do
    test "reads HTTP_PROXY environment variable" do
    System.put_env("HTTP_PROXY", "http://env-proxy.example.com:8080")

    config = Config.new(api_key: "test-key")

    assert {:http, "env-proxy.example.com", 8080, []} = config.proxy
    end

    test "reads HTTPS_PROXY environment variable" do
    System.put_env("HTTPS_PROXY", "https://env-proxy.example.com:8443")

    config = Config.new(api_key: "test-key")

    assert {:https, "env-proxy.example.com", 8443, []} = config.proxy
    end

    test "explicit proxy option overrides environment" do
    System.put_env("HTTP_PROXY", "http://env-proxy.example.com:8080")

    config = Config.new(
        api_key: "test-key",
        proxy: "http://explicit-proxy.example.com:9090"
    )

    assert {:http, "explicit-proxy.example.com", 9090, []} = config.proxy
    end

    test "prefers HTTP_PROXY over HTTPS_PROXY when both set" do
    System.put_env("HTTP_PROXY", "http://http-proxy.example.com:8080")
    System.put_env("HTTPS_PROXY", "https://https-proxy.example.com:8443")

    config = Config.new(api_key: "test-key")

    # HTTP_PROXY takes precedence
    assert {:http, "http-proxy.example.com", 8080, []} = config.proxy
    end
end
end

Test File: test/tinkex/api/api_proxy_test.exs

defmodule Tinkex.API.ProxyTest do
use ExUnit.Case, async: true

alias Tinkex.Config

describe "build_finch_request/5" do
    test "builds request without proxy when proxy is nil" do
    request = Tinkex.API.build_finch_request(
        :get,
        "https://api.example.com/test",
        [{"content-type", "application/json"}],
        nil,
        nil
    )

    assert %Finch.Request{} = request
    assert request.method == :get
    assert request.host == "api.example.com"
    # No proxy options
    end

    test "builds request with HTTP proxy" do
    proxy = {:http, "proxy.example.com", 8080, []}

    request = Tinkex.API.build_finch_request(
        :get,
        "https://api.example.com/test",
        [{"content-type", "application/json"}],
        nil,
        proxy
    )

    assert %Finch.Request{} = request
    # Verify proxy is set (may need to inspect internal structure)
    end

    test "builds request with authenticated proxy" do
    proxy = {:http, "proxy.example.com", 8080, username: "user", password: "pass"}

    request = Tinkex.API.build_finch_request(
        :post,
        "https://api.example.com/test",
        [{"content-type", "application/json"}],
        ~s({"test": true}),
        proxy
    )

    assert %Finch.Request{} = request
    end
end
end

Test File: test/tinkex/http_client/finch_client_test.exs

defmodule Tinkex.HTTPClient.FinchClientTest do
use ExUnit.Case, async: true

alias Tinkex.Config
alias Tinkex.HTTPClient.FinchClient

describe "init/1" do
    test "initializes with config" do
    config = Config.new(api_key: "test-key")

    assert {:ok, state} = FinchClient.init(config)
    assert %FinchClient{config: ^config, pool: pool} = state
    assert is_atom(pool)
    end

    test "preserves proxy config in state" do
    config = Config.new(
        api_key: "test-key",
        proxy: {:http, "proxy.example.com", 8080, []}
    )

    {:ok, state} = FinchClient.init(config)

    assert state.config.proxy == {:http, "proxy.example.com", 8080, []}
    end
end

describe "request/5" do
    setup do
    bypass = Bypass.open()
    config = Config.new(
        api_key: "test-key",
        base_url: "http://localhost:#{bypass.port}"
    )
    {:ok, state} = FinchClient.init(config)

    {:ok, bypass: bypass, state: state}
    end

    test "makes GET request", %{bypass: bypass, state: state} do
    Bypass.expect_once(bypass, "GET", "/test", fn conn ->
        Plug.Conn.resp(conn, 200, ~s({"success": true}))
    end)

    {:ok, response, _new_state} = FinchClient.request(
        :get,
        "http://localhost:#{bypass.port}/test",
        [{"accept", "application/json"}],
        nil,
        state
    )

    assert response.status == 200
    assert response.body == ~s({"success": true})
    end

    test "makes POST request with body", %{bypass: bypass, state: state} do
    Bypass.expect_once(bypass, "POST", "/test", fn conn ->
        {:ok, body, conn} = Plug.Conn.read_body(conn)
        assert body == ~s({"input": "data"})
        Plug.Conn.resp(conn, 201, ~s({"created": true}))
    end)

    {:ok, response, _new_state} = FinchClient.request(
        :post,
        "http://localhost:#{bypass.port}/test",
        [{"content-type", "application/json"}],
        ~s({"input": "data"}),
        state
    )

    assert response.status == 201
    end

    test "returns error for connection failure", %{state: state} do
    # Use a port that's definitely not listening
    {:error, error, _new_state} = FinchClient.request(
        :get,
        "http://localhost:59999/test",
        [],
        nil,
        state
    )

    assert %Tinkex.Error{} = error
    end
end
end

Test File: test/tinkex/http_client_injection_test.exs

defmodule Tinkex.HTTPClientInjectionTest do
use ExUnit.Case, async: true

defmodule MockHTTPClient do
    @behaviour Tinkex.HTTPClient

    defstruct [:calls]

    @impl true
    def init(_config) do
    {:ok, %__MODULE__{calls: []}}
    end

    @impl true
    def request(method, url, headers, body, %__MODULE__{calls: calls} = state) do
    call = %{method: method, url: url, headers: headers, body: body}
    new_state = %{state | calls: [call | calls]}

    response = %{
        status: 200,
        headers: [{"content-type", "application/json"}],
        body: ~s({"mock": true})
    }

    {:ok, response, new_state}
    end

    def get_calls(%__MODULE__{calls: calls}), do: Enum.reverse(calls)
end

describe "custom HTTP client injection" do
    test "uses injected HTTP client for requests" do
    config = Tinkex.Config.new(
        api_key: "test-key",
        http_client: MockHTTPClient
    )

    {:ok, client_state} = MockHTTPClient.init(config)

    {:ok, response, new_state} = MockHTTPClient.request(
        :get,
        "https://api.example.com/test",
        [{"accept", "application/json"}],
        nil,
        client_state
    )

    assert response.status == 200
    assert response.body == ~s({"mock": true})

    calls = MockHTTPClient.get_calls(new_state)
    assert length(calls) == 1
    assert hd(calls).method == :get
    end
end
end

Test File: test/tinkex/config_inspect_proxy_test.exs

defmodule Tinkex.ConfigInspectProxyTest do
use ExUnit.Case, async: true

alias Tinkex.Config

describe "Inspect implementation masks proxy credentials" do
    test "masks proxy password in inspect output" do
    config = Config.new(
        api_key: "test-key",
        proxy: {:http, "proxy.example.com", 8080, username: "user", password: "secret123"}
    )

    inspected = inspect(config)

    refute inspected =~ "secret123"
    assert inspected =~ "***" or inspected =~ "[REDACTED]"
    assert inspected =~ "proxy.example.com"
    assert inspected =~ "user"
    end

    test "does not mask proxy without credentials" do
    config = Config.new(
        api_key: "test-key",
        proxy: {:http, "proxy.example.com", 8080, []}
    )

    inspected = inspect(config)

    assert inspected =~ "proxy.example.com"
    assert inspected =~ "8080"
    end
end
end

Success Criteria

1. Config Proxy Tests Pass
- URL string parsing (HTTP, HTTPS, with/without auth)
- Tuple validation
- Error cases (invalid URLs, ports)
2. Environment Variable Tests Pass
- HTTP_PROXY and HTTPS_PROXY reading via `Tinkex.Env` helpers (no direct System.get_env/1)
- Explicit option overrides environment
3. API Proxy Tests Pass
- Finch request built with proxy options
- Requests work through proxy (integration test)
4. HTTPClient Tests Pass
- FinchClient initializes correctly
- Requests include proxy when configured
- Custom client injection works
5. Security Tests Pass
- Proxy credentials masked in logs/inspect
6. All Tests Pass
mix test test/tinkex/config_proxy_test.exs
mix test test/tinkex/env_proxy_test.exs
mix test test/tinkex/config_env_proxy_integration_test.exs
mix test test/tinkex/api/api_proxy_test.exs
mix test test/tinkex/http_client/
mix test test/tinkex/config_inspect_proxy_test.exs
7. Existing Tests Still Pass (backward compatibility)
mix test
8. Dialyzer Passes
mix dialyzer

Commands to Run

# Run all new proxy-related tests
mix test test/tinkex/config_proxy_test.exs test/tinkex/env_proxy_test.exs test/tinkex/config_env_proxy_integration_test.exs test/tinkex/api/api_proxy_test.exs test/tinkex/http_client/
test/tinkex/config_inspect_proxy_test.exs

# Run full test suite (verify no regressions)
mix test

# Check types
mix dialyzer

# Format code
mix format

Implementation Order

1. Red: Write test/tinkex/env_proxy_test.exs - tests fail
2. Green: Add http_proxy/1 and https_proxy/1 to lib/tinkex/env.ex
3. Refactor: Clean up
4. Red: Write test/tinkex/config_proxy_test.exs - tests fail
5. Green: Add :proxy field and parsing to lib/tinkex/config.ex
6. Refactor: Validation, error messages
7. Red: Write test/tinkex/config_env_proxy_integration_test.exs - tests fail
8. Green: Wire up env proxy to Config.new/1
9. Refactor: Priority order (explicit > env)
10. Red: Write test/tinkex/api/api_proxy_test.exs - tests fail
11. Green: Add build_finch_request/5 with proxy to lib/tinkex/api/api.ex
12. Refactor: Helper functions
13. Red: Write test/tinkex/http_client/finch_client_test.exs - tests fail
14. Green: Create lib/tinkex/http_client/finch_client.ex
15. Refactor: Response conversion
16. Red: Write test/tinkex/http_client_injection_test.exs - tests fail
17. Green: Add :http_client option to Config
18. Refactor: Integration
19. Red: Write test/tinkex/config_inspect_proxy_test.exs - tests fail
20. Green: Update Inspect implementation to mask proxy credentials
21. Refactor: Final cleanup
22. Run full test suite to verify no regressions

Backward Compatibility Notes

All changes are additive and backward compatible:

- :proxy option is optional (defaults to nil)
- Existing code without proxy continues to work unchanged
- Environment variables are only read if no explicit option provided
- :http_client option is optional (defaults to FinchClient)
- No changes to existing public API signatures

Security Considerations

1. Credential Storage - Always use environment variables or secrets management:
# GOOD
proxy: {:http, "proxy.example.com", 8080,
username: System.fetch_env!("PROXY_USER"),
password: System.fetch_env!("PROXY_PASS")
}

# BAD - Never hardcode credentials
proxy: {:http, "proxy.example.com", 8080,
username: "user",
password: "password123"
}
2. Inspect Masking - Proxy passwords are masked in logs/inspect output
   - Reuse `Tinkex.Env.mask_secret/1` in Inspect impls to stay consistent with other secrets.
3. Proxy Trust - Proxies can inspect HTTP traffic; always use HTTPS to API endpoints
