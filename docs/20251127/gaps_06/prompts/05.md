Agent Prompt: Implement Generic Request-Transform Engine for Tinkex (Gap #5)

Overview

You are implementing a generic request-transform engine for the Tinkex (Elixir) SDK that provides declarative field transformations similar to Python's annotation-driven system. Currently, Elixir uses ad-hoc runtime options via `Tinkex.Transform` and scattered `Jason.Encoder` implementations. The HTTP client calls `Transform.transform/2` before `Jason.encode!/1`, so the `Jason.Encoder` implementations under `Tinkex.Types.*` are bypassed on the request path. Today, only `drop_nil?: true` is wired (sampling API); aliases/formats are not used in production flows.

The Problem: Python uses `Annotated[T, PropertyInfo(...)]` metadata on type definitions to declaratively specify transforms (aliasing, formats, discriminators). The transform engine introspects these annotations automatically. Elixir's `Tinkex.Transform` requires explicit runtime opts and lacks a centralized, declarative approach; format/alias data is not plumbed through callers.

Important: The gap document is descriptive and proposes a future plan; none of the new Elixir modules described there exist yet.

Required Reading (IN ORDER)

Read these files to understand the problem and solution:

1. Gap Analysis Document

./docs/20251127/gaps_06/05_request_transform_engine.md
This contains the detailed analysis of what's missing and a proposed TDD implementation plan; it notes that the plan is not yet implemented and that HTTP requests currently bypass `Jason.Encoder`.

2. Python Transform Implementation

./tinker/src/tinker/_utils/_transform.py
Critical components:

Lines 42-69 - PropertyInfo metadata class:
class PropertyInfo:
    alias: str | None           # Rename field (snake_case → camelCase)
    format: PropertyFormat | None  # "iso8601", "base64", "custom"
    format_template: str | None    # Custom date format string
    discriminator: str | None      # Union discriminator field

Lines 90-110 - Main transform() function:
def transform(data: _T, expected_type: object) -> _T:
    """Transform dictionaries based off of type information from the given type"""
    transformed = _transform_recursive(data, annotation=cast(type, expected_type))
    return cast(_T, transformed)

Lines 152-227 - Recursive transformation:
- Handles TypedDicts with get_type_hints()
- Processes nested dicts, lists, unions
- Applies PropertyInfo metadata from Annotated types
- Calls _format_data() for format application

Lines 230-254 - Format handlers:
def _format_data(data: object, format_: PropertyFormat, format_template: str | None):
    if isinstance(data, (date, datetime)):
        if format_ == "iso8601":
            return data.isoformat()
        if format_ == "custom" and format_template is not None:
            return data.strftime(format_template)
    if format_ == "base64" and is_base64_file_input(data):
        # Read file and encode as base64

3. Python Models with PropertyInfo Usage

./tinker/src/tinker/_models.py
See how PropertyInfo is imported and used with discriminated unions.

4. Current Elixir Transform Module

./lib/tinkex/transform.ex
Current approach (ad-hoc, runtime):
@type opts :: [
aliases: map(),     # Explicit alias mapping
formats: map(),     # Per-key format specs
drop_nil?: boolean()
]

def transform(data, opts \\ [])
# Requires caller to pass aliases/formats every time
# Used by HTTP path before Jason.encode!/1 (see api/api.ex)

5. HTTP Usage Points

./lib/tinkex/api/api.ex (prepare_body/2 uses Transform.transform/2)
./lib/tinkex/api/sampling.ex (sets transform: [drop_nil?: true])
No other call sites supply aliases/formats today.

6. Sentinels and Minimal Tests

./lib/tinkex/not_given.ex
./test/tinkex/transform_test.exs (covers sentinels, aliases, iso8601, drop_nil?)

The Gap Explained

Python Flow (Annotation-Driven):

# Type definition with metadata annotations:
class CreateSessionRequest(TypedDict):
    model_id: Annotated[str, PropertyInfo(alias="modelId")]
    created_at: Annotated[datetime, PropertyInfo(format="iso8601")]

# Usage - just pass data and type:
data = {"model_id": "llama", "created_at": datetime.now()}
transformed = transform(data, CreateSessionRequest)
# → {"modelId": "llama", "createdAt": "2024-01-15T10:30:00Z"}

Current Elixir Flow (Ad-Hoc Runtime):

# No declarative metadata on types
# Must pass explicit opts every time:
Transform.transform(data,
aliases: %{model_id: "modelId"},
formats: %{created_at: :iso8601}
)

# Per-type Jason.Encoder implementations exist but are bypassed on HTTP path because Transform runs before Jason.encode!/1.

Target Elixir Flow (Protocol-Based Declarative):

# Declarative metadata via planned macro/protocol (see gap doc for proposed API).
# Transform uses metadata automatically, while keeping runtime opts backward compatible.

Implementation Requirements

Follow the proposed architecture in the gap doc: protocol-based metadata (`Transform.Metadata`), `Transform.Annotated` macro, richer format handlers (iso8601/base64/custom template/function), union/discriminator helpers, and backward-compatible runtime opts. None of these modules exist yet—implement them per the doc.

Format Handlers

ISO 8601

defp apply_format(:iso8601, %DateTime{} = dt), do: DateTime.to_iso8601(dt)
defp apply_format(:iso8601, %NaiveDateTime{} = dt), do: NaiveDateTime.to_iso8601(dt)
defp apply_format(:iso8601, %Date{} = d), do: Date.to_iso8601(d)

Base64

defp apply_format(:base64, binary) when is_binary(binary) do
Base.encode64(binary)
end

defp apply_format(:base64, path) when is_binary(path) do
path |> File.read!() |> Base.encode64()
end

Custom Function

defp apply_format(fun, value) when is_function(fun, 1), do: fun.(value)

TDD Implementation Plan (proposed — implement per gap doc)

- Phase 1: Metadata foundation
  - Add `Transform.Metadata` protocol and `Transform.Annotated` macro (compile-time metadata).
  - Integrate metadata-aware transform path while keeping runtime opts working.
  - Tests: metadata extraction, protocol detection, backward compatibility with existing opts and sentinel handling.
- Phase 2: Formats
  - Add base64 and custom datetime template handlers alongside iso8601 and function formats.
  - Tests: base64 (path, IO, passthrough strings), custom templates, iso8601 for Date/NaiveDateTime/DateTime.
- Phase 3: Union + discriminator helpers
  - Implement helpers for union transformation and discriminated variant selection (per gap doc).
  - Tests: multiple variants, discriminator selection, unchanged on no match.
- Phase 4: Migration/back-compat
  - Ensure API callers still work (`api/api.ex` + sampling `drop_nil?`), keep runtime opts, and add regression tests for nested structs/lists/maps.

Migration Strategy

Phase 1: Add New Modules (Non-Breaking; keep runtime opts working)

- Add metadata protocol, Annotated macro, format handlers, and union/discriminator helpers
- Enhance Transform to detect metadata
- All existing code continues to work

Phase 2: Migrate Types Gradually

- Add use Tinkex.Transform.Annotated to types
- Add @transform_meta with field info
- Remove explicit Jason.Encoder implementations one by one

Phase 3: Simplify Callers

- Remove explicit aliases/formats opts from API calls
- Transform auto-detects from type metadata

Files to Create

Use the "Proposed New Elixir Files" list in the gap doc as the source of truth (metadata protocol, annotated macro, format handlers, union/discriminator helpers, migration utilities, and corresponding tests/benchmarks).

Files to Modify

lib/tinkex/transform.ex          # Add metadata detection, merge with opts
lib/tinkex/types/*.ex            # Gradually add @transform_meta

Success Criteria

1. ✅ All new tests pass
2. ✅ Declarative metadata (Transform.Annotated + Metadata protocol) works and is persisted/accessible
3. ✅ Transform.transform/1 auto-detects metadata, keeps runtime opts backward compatible
4. ✅ HTTP path continues to work (Transform called in api/api.ex; `Jason.Encoder` remains bypassed unless changed intentionally)
5. ✅ Nested structs and lists transform correctly
6. ✅ All format handlers work: :iso8601, :base64, custom functions/templates
7. ✅ Existing code using explicit opts continues to work

Commands

# Run transform tests
mix test test/tinkex/transform/

# Run all tests
mix test

# Format code
mix format

# Compile with warnings
mix compile --warnings-as-errors

Do NOT:

- Break existing Transform.transform/2 behavior
- Remove support for runtime aliases/formats opts
- Require all types to use the new system
- Change Jason.Encoder implementations without migration path
- Add external dependencies for this feature
