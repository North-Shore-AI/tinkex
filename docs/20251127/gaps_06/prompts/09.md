Agent Prompt: Gap #9 - CLI Ergonomics and Output Formatting

Task Overview

You are implementing rich CLI output formatting for Tinkex, an Elixir port of the Tinker Python SDK. The Python CLI provides an exceptional user experience with beautiful table formatting (via rich),
progress bars for long operations, and human-readable formatting. The Elixir CLI has functional command parity (~90%) but outputs plain tab-separated text with no tables, progress bars, or styling, and only `run --json` / `version --json` support JSON (checkpoint/run management are text-only today).

This gap is high priority for developer experience - CLI UX directly impacts user satisfaction and adoption.

Required Reading

Read these files in order before implementation:

Gap Analysis Document:
- ./docs/20251127/gaps_06/09_cli_ergonomics.md

Python Reference Implementation:
- ./tinker/src/tinker/cli/output.py - OutputBase abstract class, table rendering, formatting utilities
- ./tinker/src/tinker/cli/commands/run.py - RunListOutput class, progress bar usage
- ./tinker/src/tinker/cli/commands/checkpoint.py - Download progress bars, table output

Elixir Current Implementation:
- ./lib/tinkex/cli.ex - Current CLI module (single file, ~1400 lines)
- ./test/tinkex/cli_test.exs - Current CLI tests

Gap Explanation

Python CLI Output Architecture:

# Abstract base class for all command outputs
class OutputBase(ABC):
    @abstractmethod
    def to_dict(self) -> Dict[str, Any]:
        """Convert output to dictionary for JSON serialization."""
        pass

    @abstractmethod
    def get_table_columns(self) -> List[str]:
        """Return list of column names for table output."""
        pass

    @abstractmethod
    def get_table_rows(self) -> List[List[str]]:
        """Return list of rows for table output."""
        pass

    def print(self, format: str = "table") -> None:
        if format == "json":
            self._print_json()
        else:
            self._print_table()

    def _print_table(self) -> None:
        from rich.console import Console
        from rich.table import Table

        console = Console()
        table = Table(title=self.get_title())

        # First column (ID) gets special cyan styling
        for i, col in enumerate(self.get_table_columns()):
            if i == 0:
                table.add_column(col, style="bright_cyan", no_wrap=True)
            else:
                table.add_column(col)

        for row in self.get_table_rows():
            table.add_row(*row)

        console.print(table)

Python Formatting Utilities:

def format_size(bytes: int) -> str:
    """Format bytes as human-readable size (e.g., "1.2 GB")."""

def format_timestamp(dt: Union[datetime, str, None]) -> str:
    """Format datetime as relative time or absolute date."""
    # Returns: "2 hours ago", "3 days ago", or "2024-01-15"

def format_bool(value: bool) -> str:
    """Format boolean for display."""
    # Returns: "Yes" or "No"

Python Progress Bars:

# For download operations
with click.progressbar(
    length=total_size,
    label="Downloading archive",
    show_percent=True,
    show_pos=True,
    show_eta=True,
) as bar:
    for chunk in response.iter_bytes():
        f.write(chunk)
        bar.update(len(chunk))

# For pagination
with click.progressbar(
    length=target_count,
    label=f"Fetching {target_count} runs",
    show_percent=True,
) as bar:
    while len(all_runs) < target_count:
        # ... fetch batch
        bar.update(len(batch))

Elixir Current Problems:

1. Tab-separated output (no alignment, no headers):
# Current checkpoint list output
Enum.each(resp.checkpoints, fn ckpt ->
IO.puts("#{ckpt.checkpoint_id}\t#{ckpt.tinker_path}")
end)
1. Output:
ckpt_001    tinker://run-1/weights/001
ckpt_002    tinker://run-1/weights/002
2. No progress bars for downloads or pagination
3. No metadata (total count, remaining items, pagination hints)
4. No human-readable formatting (raw bytes, ISO timestamps)
5. No JSON output for checkpoint/run management commands (only `run --json` and `version --json` exist)

Visual Comparison:

Python (rich tables):
                    3 training runs (47 more not shown, use --limit to see more)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”“
â”ƒ Run ID                               â”ƒ Base Model          â”ƒ LoRA     â”ƒ Last Update â”ƒ Status â”ƒ
â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”©
â”‚ 0478a1ab-95af-5eae-bd70-d3d3b441c021 â”‚ Qwen/Qwen2.5-0.5B   â”‚ Rank 32  â”‚ 2 hours ago â”‚ Active â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Elixir (current):
0478a1ab-95af-5eae-bd70-d3d3b441c021    Qwen/Qwen2.5-0.5B

Implementation Requirements

Phase 1: Output Formatter Module

1.1 Create Tinkex.CLI.OutputFormatter (./lib/tinkex/cli/output_formatter.ex):

defmodule Tinkex.CLI.OutputFormatter do
@moduledoc """
Output formatting utilities for the Tinkex CLI.

Provides table rendering, formatting helpers, and JSON output.
Matches Python SDK's rich output formatting.
"""

@doc """
Renders a table with the given columns and rows.

## Options
    * `:title` - Optional table title
    * `:highlight_first` - Apply cyan color to first column (default: true)
"""
@spec render_table([String.t()], [[String.t()]], keyword()) :: :ok

@doc """
Formats bytes as human-readable size.

## Examples
    iex> format_size(1_234_567_890)
    "1.1 GB"
"""
@spec format_size(integer() | nil) :: String.t()

@doc """
Formats datetime as relative time or absolute date.

## Examples
    iex> format_timestamp(~U[2025-11-27 08:00:00Z])  # if 2 hours ago
    "2 hours ago"
"""
@spec format_timestamp(DateTime.t() | String.t() | nil) :: String.t()

@doc """
Formats boolean for display.

## Examples
    iex> format_bool(true)
    "Yes"
"""
@spec format_bool(boolean()) :: String.t()

@doc """
Converts data to pretty-printed JSON string.
"""
@spec to_json(map() | struct()) :: String.t()
end

1.2 Color Helpers (using IO.ANSI - built-in, no dependency):

defp colorize_id(id) do
IO.ANSI.bright() <> IO.ANSI.cyan() <> to_string(id) <> IO.ANSI.reset()
end

defp colorize_success(text) do
IO.ANSI.green() <> text <> IO.ANSI.reset()
end

defp colorize_error(text) do
IO.ANSI.red() <> text <> IO.ANSI.reset()
end

Phase 2: Output Behaviour

2.1 Create Tinkex.CLI.Output behaviour (./lib/tinkex/cli/output.ex):

defmodule Tinkex.CLI.Output do
@moduledoc """
Behaviour for CLI command outputs.

Commands implement this behaviour to support both table and JSON output.
"""

@doc "Convert output to a map for JSON serialization."
@callback to_map() :: map()

@doc """
Convert output to table format.
Returns {columns, rows, opts}.
"""
@callback to_table() :: {[String.t()], [[String.t()]], keyword()}

@doc "Print the output in the specified format."
@spec print(module(), :table | :json) :: :ok
def print(output_module, format \\ :table)
end

Phase 3: Command-Specific Outputs

3.1 Create Tinkex.CLI.Outputs.CheckpointList (./lib/tinkex/cli/outputs/checkpoint_list.ex):

defmodule Tinkex.CLI.Outputs.CheckpointList do
@moduledoc "Output for 'tinkex checkpoint list' command."

@behaviour Tinkex.CLI.Output

defstruct [:checkpoints, :total_count, :shown_count, :run_id]

def new(checkpoints, opts \\ [])

@impl true
def to_map(%__MODULE__{} = output)

@impl true
def to_table(%__MODULE__{} = output)
# Returns columns: ["Checkpoint ID", "Type", "Size", "Public", "Created", "Path"]
# With formatted values and pagination title
end

3.2 Create Tinkex.CLI.Outputs.RunList (./lib/tinkex/cli/outputs/run_list.ex):

defmodule Tinkex.CLI.Outputs.RunList do
@moduledoc "Output for 'tinkex run list' command."

@behaviour Tinkex.CLI.Output

defstruct [:runs, :total_count, :shown_count]

# Returns columns: ["Run ID", "Base Model", "Owner", "LoRA", "Last Update", "Status"]
end

3.3 Create outputs for other commands:
- Tinkex.CLI.Outputs.CheckpointInfo
- Tinkex.CLI.Outputs.RunInfo

Phase 4: Progress Bar Module

4.1 Create Tinkex.CLI.Progress (./lib/tinkex/cli/progress.ex):

defmodule Tinkex.CLI.Progress do
@moduledoc """
Progress bars and spinners for CLI operations.
Uses the Owl library for rich progress display.
"""

@doc """
Display a progress bar for a task with known total.

## Examples
    Progress.progress_bar(1000, "Downloading", fn bar ->
        Enum.each(chunks, fn chunk ->
        Progress.update(bar, byte_size(chunk))
        end)
    end)
"""
@spec progress_bar(pos_integer(), String.t(), keyword(), (term() -> term())) :: term()

@doc "Update progress bar with increment."
@spec update(term(), pos_integer()) :: :ok

@doc """
Display a spinner for indeterminate tasks.

## Examples
    Progress.spinner("Loading model", fn -> load_model() end)
"""
@spec spinner(String.t(), (-> term())) :: term()
end

Phase 5: Integrate into CLI Commands

Add JSON flag support to management commands:
- Extend checkpoint/run management switches to accept `--json` (and optionally `--format json` alias) so list/info/download can emit JSON using the new outputs.

5.1 Update checkpoint_list/3 in ./lib/tinkex/cli.ex:

defp checkpoint_list(config, options, deps) do
limit = Map.get(options, :limit, 20)
json_mode = Map.get(options, :json, false)

# Fetch with progress bar for multi-page
checkpoints = fetch_checkpoints_with_progress(config, limit, deps, json_mode)

# Build output
output = Outputs.CheckpointList.new(
    checkpoints,
    total_count: total,
    shown_count: length(checkpoints)
)

# Print in requested format
if json_mode do
    Output.print(output, :json)
else
    Output.print(output, :table)
end

{:ok, %{command: :checkpoint, action: :list, count: length(checkpoints)}}
end

5.2 Update checkpoint_download/3 with progress bars:

defp checkpoint_download(config, options, deps) do
# ... setup ...

# Download with progress bar (unless JSON mode)
unless json_mode do
    Progress.progress_bar(file_size, "Downloading archive", fn bar ->
    download_with_callback(url, tmp_path, fn chunk_size ->
        Progress.update(bar, chunk_size)
    end)
    end)
else
    download_silent(url, tmp_path)
end

# Extract with progress bar (unless JSON mode)
unless json_mode do
    Progress.progress_bar(file_count, "Extracting archive", fn bar ->
    extract_with_callback(archive_path, dest, fn ->
        Progress.update(bar, 1)
    end)
    end)
else
    extract_silent(archive_path, dest)
end

# ... rest ...
end

Dependencies to Add

# mix.exs
defp deps do
[
    # ... existing deps ...

    # CLI Output Formatting
    {:table_rex, "~> 3.1"},   # Table rendering with borders/alignment
    {:owl, "~> 0.12"},        # Progress bars and spinners
]
end

TDD Implementation Plan

Test File: test/tinkex/cli/output_formatter_test.exs

defmodule Tinkex.CLI.OutputFormatterTest do
use ExUnit.Case, async: true
import ExUnit.CaptureIO

alias Tinkex.CLI.OutputFormatter

describe "render_table/3" do
    test "renders table with headers and rows" do
    rows = [
        ["001", "checkpoint_1", "Active"],
        ["002", "checkpoint_2", "Failed"]
    ]

    output = capture_io(fn ->
        OutputFormatter.render_table(["ID", "Name", "Status"], rows)
    end)

    assert output =~ "ID"
    assert output =~ "Name"
    assert output =~ "Status"
    assert output =~ "001"
    assert output =~ "checkpoint_1"
    assert output =~ "â”ƒ" or output =~ "|"  # Table border
    end

    test "renders empty table with headers" do
    output = capture_io(fn ->
        OutputFormatter.render_table(["ID", "Name"], [], title: "Empty Table")
    end)

    assert output =~ "Empty Table"
    assert output =~ "ID"
    end

    test "applies color to first column when enabled" do
    rows = [["001", "test"]]

    output = capture_io(fn ->
        OutputFormatter.render_table(["ID", "Name"], rows, highlight_first: true)
    end)

    # Should contain ANSI color codes
    assert output =~ IO.ANSI.cyan() or output =~ "\e[36m"
    end

    test "handles unicode characters" do
    rows = [["æµ‹è¯•", "æ—¥æœ¬èªž", "ðŸŽ‰"]]

    output = capture_io(fn ->
        OutputFormatter.render_table(["ä¸­æ–‡", "æ—¥æœ¬èªž", "Emoji"], rows)
    end)

    assert output =~ "æµ‹è¯•"
    assert output =~ "æ—¥æœ¬èªž"
    end
end

describe "format_size/1" do
    test "formats bytes as bytes" do
    assert OutputFormatter.format_size(0) == "0 B"
    assert OutputFormatter.format_size(512) == "512 B"
    assert OutputFormatter.format_size(1023) == "1023 B"
    end

    test "formats kilobytes" do
    assert OutputFormatter.format_size(1024) == "1.0 KB"
    assert OutputFormatter.format_size(1536) == "1.5 KB"
    end

    test "formats megabytes" do
    assert OutputFormatter.format_size(1_048_576) == "1.0 MB"
    assert OutputFormatter.format_size(104_857_600) == "100.0 MB"
    end

    test "formats gigabytes" do
    assert OutputFormatter.format_size(1_073_741_824) == "1.0 GB"
    assert OutputFormatter.format_size(2_576_980_377) == "2.4 GB"
    end

    test "handles nil" do
    assert OutputFormatter.format_size(nil) == "N/A"
    end

    test "handles negative values" do
    assert OutputFormatter.format_size(-100) == "N/A"
    end
end

describe "format_timestamp/1" do
    test "formats 'just now' for recent times" do
    now = DateTime.utc_now()
    thirty_seconds_ago = DateTime.add(now, -30, :second)

    assert OutputFormatter.format_timestamp(thirty_seconds_ago) == "just now"
    end

    test "formats minutes ago" do
    now = DateTime.utc_now()
    five_minutes_ago = DateTime.add(now, -5, :minute)

    assert OutputFormatter.format_timestamp(five_minutes_ago) == "5 minutes ago"
    end

    test "formats single minute" do
    now = DateTime.utc_now()
    one_minute_ago = DateTime.add(now, -1, :minute)

    assert OutputFormatter.format_timestamp(one_minute_ago) == "1 minute ago"
    end

    test "formats hours ago" do
    now = DateTime.utc_now()
    two_hours_ago = DateTime.add(now, -2, :hour)

    assert OutputFormatter.format_timestamp(two_hours_ago) == "2 hours ago"
    end

    test "formats days ago" do
    now = DateTime.utc_now()
    three_days_ago = DateTime.add(now, -3, :day)

    assert OutputFormatter.format_timestamp(three_days_ago) == "3 days ago"
    end

    test "formats weeks ago" do
    now = DateTime.utc_now()
    two_weeks_ago = DateTime.add(now, -14, :day)

    assert OutputFormatter.format_timestamp(two_weeks_ago) == "2 weeks ago"
    end

    test "formats old dates as absolute" do
    old_date = ~U[2024-01-15 10:30:00Z]
    assert OutputFormatter.format_timestamp(old_date) == "2024-01-15"
    end

    test "parses ISO 8601 strings" do
    # Recent ISO string
    now = DateTime.utc_now()
    recent = DateTime.add(now, -2, :hour) |> DateTime.to_iso8601()

    assert OutputFormatter.format_timestamp(recent) == "2 hours ago"
    end

    test "handles nil" do
    assert OutputFormatter.format_timestamp(nil) == "N/A"
    end
end

describe "format_bool/1" do
    test "formats true as Yes" do
    assert OutputFormatter.format_bool(true) == "Yes"
    end

    test "formats false as No" do
    assert OutputFormatter.format_bool(false) == "No"
    end
end

describe "to_json/1" do
    test "encodes map to pretty JSON" do
    data = %{"key" => "value", "number" => 42}
    json = OutputFormatter.to_json(data)

    assert is_binary(json)
    decoded = Jason.decode!(json)
    assert decoded["key"] == "value"
    assert decoded["number"] == 42
    end

    test "converts structs to maps" do
    defmodule TestStruct do
        defstruct [:field1, :field2]
    end

    struct = %TestStruct{field1: "a", field2: "b"}
    json = OutputFormatter.to_json(struct)

    decoded = Jason.decode!(json)
    assert decoded["field1"] == "a"
    end
end
end

Test File: test/tinkex/cli/output_test.exs

defmodule Tinkex.CLI.OutputTest do
use ExUnit.Case, async: true
import ExUnit.CaptureIO

alias Tinkex.CLI.Output

defmodule MockOutput do
    @behaviour Tinkex.CLI.Output

    defstruct [:items]

    def new(items), do: %__MODULE__{items: items}

    @impl true
    def to_map(%__MODULE__{items: items}) do
    %{"items" => items, "count" => length(items)}
    end

    @impl true
    def to_table(%__MODULE__{items: items}) do
    columns = ["ID", "Value"]
    rows = Enum.with_index(items, fn item, i -> ["#{i}", item] end)
    {columns, rows, [title: "Test Output"]}
    end
end

describe "print/2" do
    test "renders table by default" do
    output = MockOutput.new(["one", "two", "three"])

    captured = capture_io(fn ->
        Output.print(output, :table)
    end)

    assert captured =~ "Test Output"
    assert captured =~ "ID"
    assert captured =~ "Value"
    assert captured =~ "one"
    end

    test "renders JSON when requested" do
    output = MockOutput.new(["a", "b"])

    captured = capture_io(fn ->
        Output.print(output, :json)
    end)

    decoded = Jason.decode!(captured)
    assert decoded["items"] == ["a", "b"]
    assert decoded["count"] == 2
    end
end
end

Test File: test/tinkex/cli/outputs/checkpoint_list_test.exs

defmodule Tinkex.CLI.Outputs.CheckpointListTest do
use ExUnit.Case, async: true

alias Tinkex.CLI.Outputs.CheckpointList
alias Tinkex.Types.Checkpoint

describe "to_table/1" do
    test "returns correct columns" do
    output = CheckpointList.new([])
    {columns, _rows, _opts} = output |> CheckpointList.to_table()

    assert columns == ["Checkpoint ID", "Type", "Size", "Public", "Created", "Path"]
    end

    test "formats checkpoint data correctly" do
    checkpoints = [
        %Checkpoint{
        checkpoint_id: "ckpt_001",
        checkpoint_type: "weights",
        size_bytes: 2_500_000_000,
        public: true,
        time: DateTime.add(DateTime.utc_now(), -2, :hour),
        tinker_path: "tinker://run-1/weights/001"
        }
    ]

    output = CheckpointList.new(checkpoints)
    {_columns, rows, _opts} = CheckpointList.to_table(output)

    assert [[id, type, size, public, created, path]] = rows
    assert id == "ckpt_001"
    assert type == "weights"
    assert size == "2.3 GB"
    assert public == "Yes"
    assert created == "2 hours ago"
    assert path == "tinker://run-1/weights/001"
    end

    test "builds title with count" do
    checkpoints = [
        %Checkpoint{checkpoint_id: "1", tinker_path: "p1"},
        %Checkpoint{checkpoint_id: "2", tinker_path: "p2"}
    ]

    output = CheckpointList.new(checkpoints, total_count: 100, shown_count: 2)
    {_columns, _rows, opts} = CheckpointList.to_table(output)

    assert opts[:title] =~ "2 checkpoints"
    assert opts[:title] =~ "98 more not shown"
    end

    test "handles empty list" do
    output = CheckpointList.new([])
    {_columns, rows, opts} = CheckpointList.to_table(output)

    assert rows == []
    assert opts[:title] == "No checkpoints found"
    end

    test "handles single checkpoint grammar" do
    checkpoints = [%Checkpoint{checkpoint_id: "1", tinker_path: "p1"}]

    output = CheckpointList.new(checkpoints, total_count: 50, shown_count: 1)
    {_columns, _rows, opts} = CheckpointList.to_table(output)

    assert opts[:title] =~ "1 checkpoint"
    assert opts[:title] =~ "49 more not shown"
    end
end

describe "to_map/1" do
    test "returns checkpoints as list" do
    checkpoints = [
        %Checkpoint{checkpoint_id: "ckpt_001", tinker_path: "tinker://test"}
    ]

    output = CheckpointList.new(checkpoints)
    map = CheckpointList.to_map(output)

    assert is_list(map["checkpoints"])
    assert length(map["checkpoints"]) == 1
    end
end
end

Test File: test/tinkex/cli/outputs/run_list_test.exs

defmodule Tinkex.CLI.Outputs.RunListTest do
use ExUnit.Case, async: true

alias Tinkex.CLI.Outputs.RunList
alias Tinkex.Types.TrainingRun

describe "to_table/1" do
    test "returns correct columns" do
    output = RunList.new([])
    {columns, _rows, _opts} = RunList.to_table(output)

    assert columns == ["Run ID", "Base Model", "Owner", "LoRA", "Last Update", "Status"]
    end

    test "formats LoRA with rank" do
    runs = [
        %TrainingRun{
        training_run_id: "run-001",
        base_model: "Qwen/Qwen2.5-0.5B",
        model_owner: "user@example.com",
        is_lora: true,
        lora_rank: 32,
        last_request_time: DateTime.utc_now(),
        corrupted: false
        }
    ]

    output = RunList.new(runs)
    {_columns, [[_id, _model, _owner, lora, _time, _status]], _opts} = RunList.to_table(output)

    assert lora == "Rank 32"
    end

    test "formats LoRA without rank" do
    runs = [
        %TrainingRun{
        training_run_id: "run-001",
        base_model: "test",
        model_owner: "user",
        is_lora: true,
        lora_rank: nil,
        last_request_time: DateTime.utc_now(),
        corrupted: false
        }
    ]

    output = RunList.new(runs)
    {_columns, [[_id, _model, _owner, lora, _time, _status]], _opts} = RunList.to_table(output)

    assert lora == "Yes"
    end

    test "formats non-LoRA run" do
    runs = [
        %TrainingRun{
        training_run_id: "run-001",
        base_model: "test",
        model_owner: "user",
        is_lora: false,
        lora_rank: nil,
        last_request_time: DateTime.utc_now(),
        corrupted: false
        }
    ]

    output = RunList.new(runs)
    {_columns, [[_id, _model, _owner, lora, _time, _status]], _opts} = RunList.to_table(output)

    assert lora == "No"
    end

    test "shows Failed status for corrupted runs" do
    runs = [
        %TrainingRun{
        training_run_id: "run-001",
        base_model: "test",
        model_owner: "user",
        is_lora: false,
        last_request_time: DateTime.utc_now(),
        corrupted: true
        }
    ]

    output = RunList.new(runs)
    {_columns, [[_id, _model, _owner, _lora, _time, status]], _opts} = RunList.to_table(output)

    assert status == "Failed"
    end

    test "shows Active status for healthy runs" do
    runs = [
        %TrainingRun{
        training_run_id: "run-001",
        base_model: "test",
        model_owner: "user",
        is_lora: false,
        last_request_time: DateTime.utc_now(),
        corrupted: false
        }
    ]

    output = RunList.new(runs)
    {_columns, [[_id, _model, _owner, _lora, _time, status]], _opts} = RunList.to_table(output)

    assert status == "Active"
    end
end
end

Test File: test/tinkex/cli/progress_test.exs

defmodule Tinkex.CLI.ProgressTest do
use ExUnit.Case, async: true
import ExUnit.CaptureIO

alias Tinkex.CLI.Progress

describe "progress_bar/4" do
    test "displays progress bar with label" do
    output = capture_io(fn ->
        Progress.progress_bar(100, "Testing", fn bar ->
        Progress.update(bar, 100)
        end)
    end)

    assert output =~ "Testing"
    end

    test "shows completion" do
    output = capture_io(fn ->
        Progress.progress_bar(100, "Download", fn bar ->
        Enum.each(1..10, fn _ ->
            Progress.update(bar, 10)
            Process.sleep(10)
        end)
        end)
    end)

    assert output =~ "100" or output =~ "complete"
    end

    test "returns result from callback" do
    result = Progress.progress_bar(10, "Test", fn _bar ->
        :my_result
    end)

    assert result == :my_result
    end
end

describe "spinner/2" do
    test "displays spinner with label" do
    output = capture_io(fn ->
        Progress.spinner("Loading", fn ->
        Process.sleep(50)
        :done
        end)
    end)

    assert output =~ "Loading"
    end

    test "returns result from callback" do
    result = Progress.spinner("Working", fn ->
        {:ok, "completed"}
    end)

    assert result == {:ok, "completed"}
    end
end
end

Test File: test/tinkex/cli/checkpoint_list_integration_test.exs

defmodule Tinkex.CLI.CheckpointListIntegrationTest do
use ExUnit.Case
import ExUnit.CaptureIO

alias Tinkex.CLI

describe "checkpoint list with formatting" do
    setup do
    # Setup mocks for API calls
    # ...
    :ok
    end

    test "displays table with formatted output" do
    output = capture_io(fn ->
        CLI.run(["checkpoint", "list", "--limit", "5"])
    end)

    # Should have table structure
    assert output =~ "Checkpoint ID"
    assert output =~ "Type"
    assert output =~ "Size"
    assert output =~ "Public"
    assert output =~ "Created"
    assert output =~ "Path"

    # Should have borders
    assert output =~ "â”ƒ" or output =~ "|"
    end

    test "displays JSON without table formatting" do
    output = capture_io(fn ->
        CLI.run(["checkpoint", "list", "--json"])
    end)

    # Should be valid JSON
    decoded = Jason.decode!(output)
    assert is_list(decoded["checkpoints"])

    # Should NOT have table elements
    refute output =~ "â”ƒ"
    refute output =~ "â”"
    end

    test "shows progress bar for multi-page fetch" do
    output = capture_io(fn ->
        CLI.run(["checkpoint", "list", "--limit", "500"])
    end)

    assert output =~ "Fetching"
    assert output =~ "checkpoints"
    end

    test "no progress bar for single page" do
    output = capture_io(fn ->
        CLI.run(["checkpoint", "list", "--limit", "20"])
    end)

    refute output =~ "Fetching"
    end
end
end

Success Criteria

1. OutputFormatter Tests Pass
- Table rendering with headers, rows, borders
- Unicode character support
- Color application (first column cyan)
- format_size/1 covers all units (B, KB, MB, GB, TB)
- format_timestamp/1 handles relative and absolute
- format_bool/1 returns Yes/No
2. Output Behaviour Tests Pass
- Implementations correctly define callbacks
- Table/JSON mode switching works
- Integration with formatter
3. CheckpointList Output Tests Pass
- Correct column headers
- Formatted values (size, time, boolean)
- Title with count and pagination hint
- Empty list handling
4. RunList Output Tests Pass
- Correct column headers
- LoRA formatting (Rank N, Yes, No)
- Status formatting (Active, Failed)
- Pagination title
5. Progress Tests Pass
- Progress bar displays and updates
- Spinner works for indeterminate tasks
- Returns callback results
6. Integration Tests Pass
- Table output for list commands
- JSON output bypasses formatting
- Progress bars for multi-page fetches
- No progress bars in JSON mode
7. All Tests Pass
mix test test/tinkex/cli/output_formatter_test.exs
mix test test/tinkex/cli/output_test.exs
mix test test/tinkex/cli/outputs/
mix test test/tinkex/cli/progress_test.exs
mix test test/tinkex/cli/
8. Existing CLI Tests Still Pass
mix test test/tinkex/cli_test.exs
9. Dialyzer Passes
mix dialyzer

Commands to Run

# Add dependencies
mix deps.get

# Run all new CLI tests
mix test test/tinkex/cli/output_formatter_test.exs test/tinkex/cli/output_test.exs test/tinkex/cli/outputs/ test/tinkex/cli/progress_test.exs

# Run full CLI test suite
mix test test/tinkex/cli/

# Run full test suite (verify no regressions)
mix test

# Check types
mix dialyzer

# Format code
mix format

Implementation Order

1. Red: Write test/tinkex/cli/output_formatter_test.exs - all tests fail
2. Green: Implement lib/tinkex/cli/output_formatter.ex - tests pass
3. Refactor: Clean up formatting logic
4. Red: Write test/tinkex/cli/output_test.exs - tests fail
5. Green: Implement lib/tinkex/cli/output.ex behaviour - tests pass
6. Refactor: Clean up
7. Red: Write test/tinkex/cli/outputs/checkpoint_list_test.exs - tests fail
8. Green: Implement lib/tinkex/cli/outputs/checkpoint_list.ex - tests pass
9. Refactor: Extract common patterns
10. Red: Write test/tinkex/cli/outputs/run_list_test.exs - tests fail
11. Green: Implement lib/tinkex/cli/outputs/run_list.ex - tests pass
12. Refactor: Share formatting logic
13. Red: Write test/tinkex/cli/progress_test.exs - tests fail
14. Green: Implement lib/tinkex/cli/progress.ex - tests pass
15. Refactor: Error handling
16. Red: Write integration tests - tests fail
17. Green: Update lib/tinkex/cli.ex commands to use new outputs
18. Refactor: Remove old inline formatting
19. Add dependencies to mix.exs
20. Run full test suite to verify no regressions
21. Manual testing of CLI output

File Structure After Implementation

lib/tinkex/cli/
â”œâ”€â”€ output_formatter.ex        # Table rendering, formatting utilities
â”œâ”€â”€ output.ex                  # Output behaviour
â”œâ”€â”€ progress.ex                # Progress bars and spinners
â””â”€â”€ outputs/                   # Command-specific outputs
    â”œâ”€â”€ checkpoint_list.ex
    â”œâ”€â”€ checkpoint_info.ex
    â”œâ”€â”€ run_list.ex
    â””â”€â”€ run_info.ex

test/tinkex/cli/
â”œâ”€â”€ output_formatter_test.exs  # ~100 assertions
â”œâ”€â”€ output_test.exs            # ~20 assertions
â”œâ”€â”€ progress_test.exs          # ~20 assertions
â””â”€â”€ outputs/
    â”œâ”€â”€ checkpoint_list_test.exs  # ~50 assertions
    â”œâ”€â”€ checkpoint_info_test.exs  # ~30 assertions
    â”œâ”€â”€ run_list_test.exs         # ~40 assertions
    â””â”€â”€ run_info_test.exs         # ~30 assertions

Backward Compatibility Notes

All changes are additive and backward compatible:

- Existing `run --json` and `version --json` continue to work
- New `--json` (and optional `--format json`) added to checkpoint/run management; defaults remain table output
- Command parsing otherwise unchanged
- Output formatting is additive
- No breaking changes to return values
- Tests verify existing functionality preserved
