Agent Prompt: Gap #7 - Raw REST "extra_*" Extension Points

Task Overview

You are implementing full REST API extension points for Tinkex, an Elixir port of the Tinker Python SDK. The Python SDK provides a flexible, extensible HTTP request system through five "extra_*"
parameters that allow users to augment requests beyond the defined API schema. The Elixir implementation currently supports headers, per-request timeouts, per-request `max_retries`, and idempotency
keys on non-GET endpoints—but lacks mechanisms for extending query parameters (:extra_query) or body fields (:extra_body). Elixir also ignores `:idempotency_key` for GET unless a caller adds the
header manually.

Required Reading

Read these files in order before implementation:

Gap Analysis Document:
- ./docs/20251127/gaps_06/07_rest_extra_extensions.md

Python Reference Implementation:
- ./tinker/src/tinker/_base_client.py - make_request_options() function (lines 1288-1322), _build_request() (lines 426-450), body merging logic
- ./tinker/src/tinker/_qs.py - Querystring class for proper query string encoding with array/nested support
- ./tinker/src/tinker/_types.py - RequestOptions TypedDict definition
- ./tinker/src/tinker/_models.py - FinalRequestOptions class with extra_json field
- ./tinker/src/tinker/resources/training.py - Example resource method signatures showing extra_* params

Elixir Current Implementation:
- ./lib/tinkex/api/api.ex - Core HTTP client, post/3 and get/2 functions
- ./lib/tinkex/api/rest.ex - REST endpoints using ad-hoc string interpolation for query strings
- ./lib/tinkex/api/training.ex - Training API endpoints

Gap Explanation

Python Extension System:

Mutation endpoints expose a uniform extension surface; read-only endpoints omit `idempotency_key`/`max_retries` and rely on the client default retry policy (a header can still be forwarded if provided):

# Mutation endpoints accept these extension params (read-only endpoints drop idempotency/max_retries)
async def forward_backward(
    self,
    *,
    request: ForwardBackwardRequest,
    extra_headers: Headers | None = None,      # ✅ Elixir has this
    extra_query: Query | None = None,          # ❌ Missing in Elixir
    extra_body: Body | None = None,            # ❌ Missing in Elixir
    timeout: float | httpx.Timeout | None = NOT_GIVEN,  # ✅ Elixir has this
    idempotency_key: str | None = None,        # ✅ Elixir has this
) -> UntypedAPIFuture:

Note: Python read-only endpoints still accept `extra_headers`/`extra_query`/`extra_body`/`timeout` but do not expose `idempotency_key` or `max_retries`; Elixir ignores `:idempotency_key` on GET unless supplied via `:headers`.

Query Parameter Handling in Python:

# _base_client.py - make_request_options
def make_request_options(
    *,
    query: Query | None = None,
    extra_query: Query | None = None,
    # ...
) -> RequestOptions:
    options: RequestOptions = {}

    if query is not None:
        options["params"] = query

    # extra_query MERGES with base query params
    if extra_query is not None:
        options["params"] = {**options.get("params", {}), **extra_query}

    return options

Body Field Merging in Python:

# _base_client.py - _build_request
def _build_request(self, options: FinalRequestOptions, ...) -> httpx.Request:
    json_data = options.json_data

    # Merge extra_json (from extra_body) into json_data
    if options.extra_json is not None:
        if json_data is None:
            json_data = cast(Body, options.extra_json)
        elif is_mapping(json_data):
            json_data = _merge_mappings(json_data, options.extra_json)
        else:
            raise RuntimeError(
                f"Unexpected JSON data type, cannot merge with extra_body"
            )

Query String Builder in Python (_qs.py):

class Querystring:
    """Handles arrays, nested objects, URL encoding properly."""

    def stringify(self, params: Params) -> str:
        # Converts {"ids": [1, 2, 3]} -> "ids=1&ids=2&ids=3" (repeat format)
        # Converts {"filter": {"status": "active"}} -> "filter[status]=active"
        # Handles special characters via URL encoding
        return urlencode(self.stringify_items(params))

Elixir Current Problems:

1. Ad-hoc query string construction (brittle, no encoding):
# rest.ex - String interpolation, no URL encoding
def list_sessions(config, limit \\ 20, offset \\ 0) do
path = "/api/v1/sessions?limit=#{limit}&offset=#{offset}"  # ❌
API.get(path, config: config, pool_type: :training)
end
2. No :extra_query option - Cannot dynamically add query params:
# Cannot do this in Elixir:
API.get("/api/v1/sessions",
config: config,
query: %{"limit" => 20},
extra_query: %{"filter" => "active", "sort" => "created_at"}  # ❌ Not supported
)
3. No :extra_body option - Cannot dynamically extend request body:
# Cannot do this in Elixir:
API.post("/api/v1/forward", base_request,
config: config,
extra_body: %{"experimental_feature" => true}  # ❌ Not supported
)

Implementation Requirements

Phase 1: Query Parameter Module

1.1 Create Tinkex.API.QueryParams (./lib/tinkex/api/query_params.ex):

defmodule Tinkex.API.QueryParams do
@moduledoc """
Query string parameter encoding and merging utilities.

Provides Python SDK parity for query parameter handling including:
- Proper URL encoding of special characters
- Array expansion (repeat format: ids=1&ids=2&ids=3)
- Nil value filtering
- Parameter merging with override semantics
"""

@doc """
Encode a map of query parameters to a URL-encoded query string.

## Array Handling
Arrays are expanded using "repeat" format (Python SDK default):
- `%{"ids" => [1, 2, 3]}` → `"ids=1&ids=2&ids=3"`

## Nil Handling
Nil values are omitted from the query string.

## Examples

    iex> QueryParams.encode(%{"limit" => 20, "offset" => 0})
    "limit=20&offset=0"

    iex> QueryParams.encode(%{"name" => "hello world"})
    "name=hello+world"

    iex> QueryParams.encode(%{"ids" => [1, 2, 3]})
    "ids=1&ids=2&ids=3"
"""
@spec encode(map() | nil) :: String.t()

@doc """
Merge two query parameter maps. Extra params override base params.

## Examples

    iex> QueryParams.merge(%{"limit" => 20}, %{"offset" => 10})
    %{"limit" => 20, "offset" => 10}

    iex> QueryParams.merge(%{"limit" => 20}, %{"limit" => 50})
    %{"limit" => 50}
"""
@spec merge(map() | nil, map() | nil) :: map()
end

Phase 2: Body Merging Logic

2.1 Add body merging to Tinkex.API (./lib/tinkex/api/api.ex):

# Add to post/3 function
def post(path, body, opts) do
config = Keyword.fetch!(opts, :config)

# NEW: Query parameter handling
base_query = Keyword.get(opts, :query)
extra_query = Keyword.get(opts, :extra_query)
merged_query = QueryParams.merge(base_query, extra_query)
path_with_query = append_query_string(path, merged_query)

# NEW: Body merging
extra_body = Keyword.get(opts, :extra_body)
merged_body = merge_body(body, extra_body)

url = build_url(config.base_url, path_with_query)
# ... rest uses merged_body instead of body
end

# Helper functions
defp append_query_string(path, nil), do: path
defp append_query_string(path, query) when query == %{}, do: path
defp append_query_string(path, query) do
query_string = QueryParams.encode(query)
if String.contains?(path, "?") do
    "#{path}&#{query_string}"
else
    "#{path}?#{query_string}"
end
end

defp merge_body(nil, nil), do: nil
defp merge_body(nil, extra) when is_map(extra), do: extra
defp merge_body(base, nil), do: base
defp merge_body(base, extra) when is_map(base) and is_map(extra) do
Map.merge(base, extra)
end
defp merge_body(base, extra) do
raise ArgumentError, """
Cannot merge extra_body - base body must be a map.
Base body type: #{inspect(base)}
Extra body: #{inspect(extra)}
"""
end

Phase 3: Update REST Module

3.1 Refactor Tinkex.API.Rest to use proper query params:

# BEFORE (string interpolation)
def list_sessions(config, limit \\ 20, offset \\ 0) do
path = "/api/v1/sessions?limit=#{limit}&offset=#{offset}"
API.get(path, config: config, pool_type: :training)
end

# AFTER (proper query handling with extension support)
def list_sessions(config, limit \\ 20, offset \\ 0, opts \\ []) do
query = %{"limit" => limit, "offset" => offset}

opts =
    [config: config, pool_type: :training, query: query]
    |> Keyword.merge(opts)

API.get("/api/v1/sessions", opts)
end

TDD Implementation Plan

Test File: test/tinkex/api/query_params_test.exs

defmodule Tinkex.API.QueryParamsTest do
use ExUnit.Case, async: true

alias Tinkex.API.QueryParams

describe "encode/1" do
    test "encodes simple key-value pairs" do
    result = QueryParams.encode(%{"limit" => 20, "offset" => 0})
    # Order may vary, check both params present
    assert result =~ "limit=20"
    assert result =~ "offset=0"
    assert result =~ "&"
    end

    test "URL-encodes special characters" do
    assert QueryParams.encode(%{"name" => "hello world"}) == "name=hello+world"
    end

    test "URL-encodes equals sign in value" do
    result = QueryParams.encode(%{"filter" => "status=active"})
    assert result == "filter=status%3Dactive"
    end

    test "handles arrays as repeated keys (Python SDK default)" do
    result = QueryParams.encode(%{"ids" => [1, 2, 3]})
    assert result == "ids=1&ids=2&ids=3"
    end

    test "handles string arrays" do
    result = QueryParams.encode(%{"tags" => ["foo", "bar"]})
    assert result == "tags=foo&tags=bar"
    end

    test "omits nil values from query string" do
    result = QueryParams.encode(%{"a" => 1, "b" => nil, "c" => 3})
    assert result =~ "a=1"
    assert result =~ "c=3"
    refute result =~ "b="
    end

    test "handles empty map" do
    assert QueryParams.encode(%{}) == ""
    end

    test "handles nil input" do
    assert QueryParams.encode(nil) == ""
    end

    test "encodes boolean values as strings" do
    result = QueryParams.encode(%{"active" => true, "deleted" => false})
    assert result =~ "active=true"
    assert result =~ "deleted=false"
    end

    test "handles integer values" do
    assert QueryParams.encode(%{"page" => 5}) == "page=5"
    end

    test "handles float values" do
    assert QueryParams.encode(%{"threshold" => 0.95}) == "threshold=0.95"
    end
end

describe "merge/2" do
    test "merges two query param maps" do
    base = %{"limit" => 20}
    extra = %{"offset" => 10, "filter" => "active"}

    result = QueryParams.merge(base, extra)
    assert result == %{"limit" => 20, "offset" => 10, "filter" => "active"}
    end

    test "extra params override base params" do
    base = %{"limit" => 20, "offset" => 0}
    extra = %{"limit" => 50}

    result = QueryParams.merge(base, extra)
    assert result == %{"limit" => 50, "offset" => 0}
    end

    test "handles nil base" do
    extra = %{"limit" => 20}
    assert QueryParams.merge(nil, extra) == extra
    end

    test "handles nil extra" do
    base = %{"limit" => 20}
    assert QueryParams.merge(base, nil) == base
    end

    test "handles both nil" do
    assert QueryParams.merge(nil, nil) == %{}
    end

    test "handles empty maps" do
    assert QueryParams.merge(%{}, %{"a" => 1}) == %{"a" => 1}
    assert QueryParams.merge(%{"a" => 1}, %{}) == %{"a" => 1}
    end
end
end

Test File: test/tinkex/api/extra_query_test.exs

defmodule Tinkex.API.ExtraQueryTest do
use ExUnit.Case, async: true

alias Tinkex.API
alias Tinkex.API.QueryParams

# Test the query string appending logic
describe "append_query_string/2" do
    test "appends query to path without existing query" do
    path = "/api/v1/sessions"
    query = %{"limit" => 20, "offset" => 0}

    result = API.append_query_string(path, query)

    assert result =~ "/api/v1/sessions?"
    assert result =~ "limit=20"
    assert result =~ "offset=0"
    end

    test "appends to path with existing query string" do
    path = "/api/v1/sessions?existing=true"
    query = %{"limit" => 20}

    result = API.append_query_string(path, query)

    assert result =~ "/api/v1/sessions?existing=true&"
    assert result =~ "limit=20"
    end

    test "returns path unchanged for nil query" do
    path = "/api/v1/sessions"
    assert API.append_query_string(path, nil) == path
    end

    test "returns path unchanged for empty query" do
    path = "/api/v1/sessions"
    assert API.append_query_string(path, %{}) == path
    end
end

describe "post/3 with :extra_query" do
    setup do
    # Setup test config and bypass for HTTP mocking
    bypass = Bypass.open()
    config = %Tinkex.Config{
        api_key: "test-key",
        base_url: "http://localhost:#{bypass.port}",
        timeout: 5000,
        max_retries: 0,
        http_pool: Tinkex.TestPool
    }
    {:ok, bypass: bypass, config: config}
    end

    test "merges :query and :extra_query into URL", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "POST", "/api/v1/test", fn conn ->
        # Verify query params in URL
        query = conn.query_string |> URI.decode_query()

        assert query["limit"] == "20"
        assert query["offset"] == "0"
        assert query["debug"] == "true"
        assert query["verbose"] == "1"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"status" => "ok"}))
    end)

    {:ok, _} = API.post(
        "/api/v1/test",
        %{},
        config: config,
        query: %{"limit" => 20, "offset" => 0},
        extra_query: %{"debug" => "true", "verbose" => "1"}
    )
    end

    test ":extra_query overrides :query params", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "POST", "/api/v1/test", fn conn ->
        query = conn.query_string |> URI.decode_query()

        # extra_query's limit should win
        assert query["limit"] == "50"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"status" => "ok"}))
    end)

    {:ok, _} = API.post(
        "/api/v1/test",
        %{},
        config: config,
        query: %{"limit" => 20},
        extra_query: %{"limit" => 50}
    )
    end

    test "handles arrays in :extra_query", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "POST", "/api/v1/test", fn conn ->
        # Arrays should be repeated: ids=1&ids=2&ids=3
        assert conn.query_string =~ "ids=1"
        assert conn.query_string =~ "ids=2"
        assert conn.query_string =~ "ids=3"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"status" => "ok"}))
    end)

    {:ok, _} = API.post(
        "/api/v1/test",
        %{},
        config: config,
        extra_query: %{"ids" => [1, 2, 3]}
    )
    end
end

describe "get/2 with :extra_query" do
    setup do
    bypass = Bypass.open()
    config = %Tinkex.Config{
        api_key: "test-key",
        base_url: "http://localhost:#{bypass.port}",
        timeout: 5000,
        max_retries: 0,
        http_pool: Tinkex.TestPool
    }
    {:ok, bypass: bypass, config: config}
    end

    test "applies :extra_query to GET requests", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "GET", "/api/v1/sessions", fn conn ->
        query = conn.query_string |> URI.decode_query()

        assert query["limit"] == "20"
        assert query["filter"] == "active"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"sessions" => []}))
    end)

    {:ok, _} = API.get(
        "/api/v1/sessions",
        config: config,
        query: %{"limit" => 20},
        extra_query: %{"filter" => "active"}
    )
    end
end
end

Test File: test/tinkex/api/extra_body_test.exs

defmodule Tinkex.API.ExtraBodyTest do
use ExUnit.Case, async: true

alias Tinkex.API

describe "merge_body/2" do
    test "merges extra body fields into base body" do
    base = %{"model_id" => "model-123", "inputs" => [1, 2, 3]}
    extra = %{"debug" => true, "trace_gradients" => true}

    result = API.merge_body(base, extra)

    assert result["model_id"] == "model-123"
    assert result["inputs"] == [1, 2, 3]
    assert result["debug"] == true
    assert result["trace_gradients"] == true
    end

    test "extra body fields override base body fields" do
    base = %{"model_id" => "model-123", "timeout" => 30}
    extra = %{"timeout" => 60}

    result = API.merge_body(base, extra)

    assert result["timeout"] == 60
    end

    test "handles nil base body" do
    extra = %{"experimental" => true}

    result = API.merge_body(nil, extra)

    assert result == %{"experimental" => true}
    end

    test "handles nil extra body" do
    base = %{"model_id" => "model-123"}

    result = API.merge_body(base, nil)

    assert result == %{"model_id" => "model-123"}
    end

    test "handles both nil" do
    assert API.merge_body(nil, nil) == nil
    end

    test "raises for non-map base body with extra body" do
    assert_raise ArgumentError, ~r/base body must be a map/, fn ->
        API.merge_body("string body", %{"extra" => true})
    end
    end
end

describe "post/3 with :extra_body" do
    setup do
    bypass = Bypass.open()
    config = %Tinkex.Config{
        api_key: "test-key",
        base_url: "http://localhost:#{bypass.port}",
        timeout: 5000,
        max_retries: 0,
        http_pool: Tinkex.TestPool
    }
    {:ok, bypass: bypass, config: config}
    end

    test "merges :extra_body into request body", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "POST", "/api/v1/forward", fn conn ->
        {:ok, body, conn} = Plug.Conn.read_body(conn)
        decoded = Jason.decode!(body)

        # Base body fields
        assert decoded["model_id"] == "model-123"
        assert decoded["inputs"] == [1, 2, 3]

        # Extra body fields
        assert decoded["debug"] == true
        assert decoded["trace_gradients"] == true

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"status" => "ok"}))
    end)

    {:ok, _} = API.post(
        "/api/v1/forward",
        %{"model_id" => "model-123", "inputs" => [1, 2, 3]},
        config: config,
        extra_body: %{"debug" => true, "trace_gradients" => true}
    )
    end

    test ":extra_body overrides base body fields", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "POST", "/api/v1/forward", fn conn ->
        {:ok, body, conn} = Plug.Conn.read_body(conn)
        decoded = Jason.decode!(body)

        # Extra body timeout should override
        assert decoded["timeout"] == 60

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"status" => "ok"}))
    end)

    {:ok, _} = API.post(
        "/api/v1/forward",
        %{"model_id" => "model-123", "timeout" => 30},
        config: config,
        extra_body: %{"timeout" => 60}
    )
    end

    test "handles nil base body with :extra_body", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "POST", "/api/v1/test", fn conn ->
        {:ok, body, conn} = Plug.Conn.read_body(conn)
        decoded = Jason.decode!(body)

        assert decoded == %{"experimental" => true}

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"status" => "ok"}))
    end)

    {:ok, _} = API.post(
        "/api/v1/test",
        nil,
        config: config,
        extra_body: %{"experimental" => true}
    )
    end
end
end

Test File: test/tinkex/api/rest_query_test.exs

defmodule Tinkex.API.RestQueryTest do
use ExUnit.Case, async: true

alias Tinkex.API.Rest

describe "list_sessions/4 with extra opts" do
    setup do
    bypass = Bypass.open()
    config = %Tinkex.Config{
        api_key: "test-key",
        base_url: "http://localhost:#{bypass.port}",
        timeout: 5000,
        max_retries: 0,
        http_pool: Tinkex.TestPool
    }
    {:ok, bypass: bypass, config: config}
    end

    test "supports extra_query parameter", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "GET", "/api/v1/sessions", fn conn ->
        query = conn.query_string |> URI.decode_query()

        # Base params from function args
        assert query["limit"] == "20"
        assert query["offset"] == "0"

        # Extra params from opts
        assert query["filter"] == "active"
        assert query["sort"] == "created_at"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{
        "sessions" => [],
        "total" => 0
        }))
    end)

    {:ok, _} = Rest.list_sessions(config, 20, 0,
        extra_query: %{"filter" => "active", "sort" => "created_at"}
    )
    end

    test "extra_query can override default params", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "GET", "/api/v1/sessions", fn conn ->
        query = conn.query_string |> URI.decode_query()

        # extra_query limit should override function default
        assert query["limit"] == "100"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"sessions" => []}))
    end)

    {:ok, _} = Rest.list_sessions(config, 20, 0,
        extra_query: %{"limit" => 100}
    )
    end
end

describe "list_user_checkpoints/4 with extra opts" do
    setup do
    bypass = Bypass.open()
    config = %Tinkex.Config{
        api_key: "test-key",
        base_url: "http://localhost:#{bypass.port}",
        timeout: 5000,
        max_retries: 0,
        http_pool: Tinkex.TestPool
    }
    {:ok, bypass: bypass, config: config}
    end

    test "supports extra_query for filtering", %{bypass: bypass, config: config} do
    Bypass.expect(bypass, "GET", "/api/v1/checkpoints", fn conn ->
        query = conn.query_string |> URI.decode_query()

        assert query["status"] == "completed"
        assert query["min_step"] == "1000"

        Plug.Conn.resp(conn, 200, Jason.encode!(%{"checkpoints" => []}))
    end)

    {:ok, _} = Rest.list_user_checkpoints(config, 50, 0,
        extra_query: %{"status" => "completed", "min_step" => 1000}
    )
    end
end
end

Success Criteria

1. QueryParams Module Tests Pass
- encode/1 properly URL-encodes all value types
- Arrays expand to repeated keys (ids=1&ids=2&ids=3)
- Nil values are filtered out
- merge/2 correctly combines maps with override semantics
2. API Extension Tests Pass
- :query option adds query params to URL
- :extra_query merges with :query, overriding duplicates
- :extra_body merges with request body, overriding duplicates
- Error raised for non-map body with :extra_body
3. REST Module Tests Pass
- Refactored functions accept optional opts parameter
- extra_query works through REST module functions
- Backward compatible (existing calls still work)
4. All Tests Pass
mix test test/tinkex/api/query_params_test.exs
mix test test/tinkex/api/extra_query_test.exs
mix test test/tinkex/api/extra_body_test.exs
mix test test/tinkex/api/rest_query_test.exs
5. Existing Tests Still Pass
mix test
6. Dialyzer Passes
mix dialyzer

Commands to Run

# Run all new tests
mix test test/tinkex/api/query_params_test.exs test/tinkex/api/extra_query_test.exs test/tinkex/api/extra_body_test.exs test/tinkex/api/rest_query_test.exs

# Run full test suite (verify backward compatibility)
mix test

# Check types
mix dialyzer

# Format code
mix format

Implementation Order

1. Red: Write test/tinkex/api/query_params_test.exs - all tests fail
2. Green: Implement lib/tinkex/api/query_params.ex - tests pass
3. Refactor: Clean up edge cases
4. Red: Write test/tinkex/api/extra_query_test.exs - tests fail
5. Green: Update lib/tinkex/api/api.ex with :query and :extra_query support
6. Refactor: Ensure query string building is clean
7. Red: Write test/tinkex/api/extra_body_test.exs - tests fail
8. Green: Add merge_body/2 and :extra_body support to post/3
9. Refactor: Error messages and edge cases
10. Red: Write test/tinkex/api/rest_query_test.exs - tests fail
11. Green: Refactor lib/tinkex/api/rest.ex functions to use query params
12. Refactor: Ensure backward compatibility
13. Run full test suite to verify no regressions
14. Update documentation with examples

Backward Compatibility Notes

All changes are additive and backward compatible:

- Existing code using string interpolation in paths still works
- New :query, :extra_query, :extra_body options are optional
- REST module functions gain optional opts parameter with default []
- No breaking changes to existing function signatures
