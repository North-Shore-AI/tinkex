Agent Prompt: Implement Full Server Capabilities Type Information for Tinkex (Gap #3)

Overview

You are restoring full type fidelity for server capabilities across both SDKs. Currently:
- Python `SupportedModel` only types `model_name` and inherits `extra="ignore"`, so FastAPI strips `model_id`/`arch` from responses.
- Elixir flattens the response further to `[String.t()]`, losing even the minimal struct shape.

The Problem: The response loses `model_id` and `arch` before it reaches clients, and the Elixir layer removes structure entirely. This prevents validation, architecture-aware logic, and parity when the server adds metadata.

Required Reading (IN ORDER)

Read these files to understand the problem and solution:

1. Gap Analysis Document

./docs/20251127/gaps_06/03_server_capabilities_types.md
This contains the detailed analysis of what's missing and a TDD implementation plan.

2. Python Type Definitions

./tinker/src/tinker/types/get_server_capabilities_response.py
The full file:
from typing import List, Optional
from .._models import BaseModel

__all__ = ["GetServerCapabilitiesResponse", "SupportedModel"]

class SupportedModel(BaseModel):
    model_name: Optional[str] = None

class GetServerCapabilitiesResponse(BaseModel):
    supported_models: List[SupportedModel]

Note: With `extra="ignore"` untyped fields are dropped. As written, `model_id` and `arch` do not reach the HTTP response or the Python client—you must add these fields (and optionally allow extras) to emit them.

3. Current Elixir Implementation

./lib/tinkex/types/get_server_capabilities_response.ex
The problem - extracts only model_name strings:
@type t :: %__MODULE__{
supported_models: [String.t()]  # ← Should be [SupportedModel.t()]
}

def from_json(map) do
models = map["supported_models"] || []
names = models
    |> Enum.map(fn
    %{"model_name" => name} -> name  # ← Throws away everything except name
    ...
    end)
%__MODULE__{supported_models: names}
end

4. Related Elixir Type (Pattern to Follow)

./lib/tinkex/types/model_data.ex
This shows the pattern we SHOULD be using - a proper struct with all fields:
defstruct [:arch, :model_name, :tokenizer_id]

@type t :: %__MODULE__{
arch: String.t() | nil,
model_name: String.t() | nil,
tokenizer_id: String.t() | nil
}

5. Service API Usage

./lib/tinkex/api/service.ex
Shows how GetServerCapabilitiesResponse is created from JSON.

6. Current Tests

./test/tinkex/api/service_test.exs
Shows the current test that reinforces the string-only behavior.

Gap Explained (current state)
- FastAPI response (via `response_model=GetServerCapabilitiesResponse`) strips `model_id`/`arch`; clients only see `model_name`.
- Python SDK therefore exposes only `model_name`.
- Elixir further flattens to strings, losing struct shape.

Target Behavior
- FastAPI response includes `model_id` and `arch`.
- Python SDK exposes `SupportedModel` with those fields (and retains future fields).
- Elixir `SupportedModel` struct preserves `model_id`, `model_name`, `arch` (and is backward compatible with string entries).

Implementation Requirements

Python changes:
- Add `model_id` and `arch` to `SupportedModel` (consider allowing extras for future fields).
- Ensure FastAPI serialization returns these fields; update/mock tests accordingly.

Elixir: New Module to Create:

Tinkex.Types.SupportedModel

defmodule Tinkex.Types.SupportedModel do
defstruct [:model_id, :model_name, :arch]

@type t :: %__MODULE__{
    model_id: String.t() | nil,
    model_name: String.t() | nil,
    arch: String.t() | nil
}

@spec from_json(map()) :: t()
def from_json(json) when is_map(json) do
    # Implementation; accept string/atom keys and ignore/allow unknowns without crashing
end
end

Module to Modify:

Tinkex.Types.GetServerCapabilitiesResponse

defmodule Tinkex.Types.GetServerCapabilitiesResponse do
alias Tinkex.Types.SupportedModel

@type t :: %__MODULE__{
    supported_models: [SupportedModel.t()]  # Changed from [String.t()]
}

def from_json(map) do
    models = map["supported_models"] || []
    parsed = Enum.map(models, &parse_model/1)
    %__MODULE__{supported_models: parsed}
end

# Backward compatible: handle both object and string formats
defp parse_model(%{} = json), do: SupportedModel.from_json(json)
defp parse_model(name) when is_binary(name), do: %SupportedModel{model_name: name}
end

TDD Implementation Plan

Phase 1: Create SupportedModel Type

Create test/tinkex/types/supported_model_test.exs:

defmodule Tinkex.Types.SupportedModelTest do
use ExUnit.Case, async: true

alias Tinkex.Types.SupportedModel

describe "from_json/1" do
    test "parses model_name from string keys" do
    json = %{"model_name" => "meta-llama/Llama-3-8B"}
    model = SupportedModel.from_json(json)

    assert model.model_name == "meta-llama/Llama-3-8B"
    end

    test "parses model_name from atom keys" do
    json = %{model_name: "meta-llama/Llama-3-8B"}
    model = SupportedModel.from_json(json)

    assert model.model_name == "meta-llama/Llama-3-8B"
    end

    test "parses all known fields" do
    json = %{
        "model_name" => "meta-llama/Llama-3-8B",
        "model_id" => "llama-3-8b",
        "arch" => "llama"
    }

    model = SupportedModel.from_json(json)

    assert model.model_name == "meta-llama/Llama-3-8B"
    assert model.model_id == "llama-3-8b"
    assert model.arch == "llama"
    end

    test "handles missing optional fields" do
    json = %{"model_name" => "test"}
    model = SupportedModel.from_json(json)

    assert model.model_name == "test"
    assert model.model_id == nil
    assert model.arch == nil
    end

    test "handles empty map" do
    model = SupportedModel.from_json(%{})

    assert model.model_name == nil
    end
end

describe "struct" do
    test "has correct fields" do
    model = %SupportedModel{}

    assert Map.has_key?(model, :model_name)
    assert Map.has_key?(model, :model_id)
    assert Map.has_key?(model, :arch)
    end
end
end

Phase 2: Update GetServerCapabilitiesResponse

Update test/tinkex/types/get_server_capabilities_response_test.exs:

defmodule Tinkex.Types.GetServerCapabilitiesResponseTest do
use ExUnit.Case, async: true

alias Tinkex.Types.{GetServerCapabilitiesResponse, SupportedModel}

describe "from_json/1" do
    test "parses list of model objects" do
    json = %{
        "supported_models" => [
        %{"model_name" => "llama", "arch" => "llama"},
        %{"model_name" => "qwen", "arch" => "qwen"}
        ]
    }

    response = GetServerCapabilitiesResponse.from_json(json)

    assert length(response.supported_models) == 2
    assert [%SupportedModel{} | _] = response.supported_models

    [first, second] = response.supported_models
    assert first.model_name == "llama"
    assert first.arch == "llama"
    assert second.model_name == "qwen"
    end

    test "handles legacy string format (backward compatibility)" do
    json = %{
        "supported_models" => ["llama", "qwen"]
    }

    response = GetServerCapabilitiesResponse.from_json(json)

    assert length(response.supported_models) == 2
    assert [%SupportedModel{model_name: "llama"}, %SupportedModel{model_name: "qwen"}] =
                response.supported_models
    end

    test "handles mixed format" do
    json = %{
        "supported_models" => [
        %{"model_name" => "llama"},
        "qwen"
        ]
    }

    response = GetServerCapabilitiesResponse.from_json(json)

    assert length(response.supported_models) == 2
    [first, second] = response.supported_models
    assert %SupportedModel{model_name: "llama"} = first
    assert %SupportedModel{model_name: "qwen"} = second
    end

    test "handles empty supported_models" do
    json = %{"supported_models" => []}

    response = GetServerCapabilitiesResponse.from_json(json)

    assert response.supported_models == []
    end

    test "handles missing supported_models key" do
    response = GetServerCapabilitiesResponse.from_json(%{})

    assert response.supported_models == []
    end

    test "preserves all model metadata" do
    json = %{
        "supported_models" => [
        %{
            "model_name" => "meta-llama/Llama-3-8B",
            "model_id" => "llama-3-8b",
            "arch" => "llama"
        }
        ]
    }

    response = GetServerCapabilitiesResponse.from_json(json)
    [model] = response.supported_models

    assert model.model_name == "meta-llama/Llama-3-8B"
    assert model.model_id == "llama-3-8b"
    assert model.arch == "llama"
    end
end

describe "model_names/1 helper" do
    test "extracts model names for convenience" do
    response = %GetServerCapabilitiesResponse{
        supported_models: [
        %SupportedModel{model_name: "llama"},
        %SupportedModel{model_name: "qwen"}
        ]
    }

    assert GetServerCapabilitiesResponse.model_names(response) == ["llama", "qwen"]
    end
end
end

Phase 3: Update Service Test

Update test/tinkex/api/service_test.exs:

test "get_server_capabilities returns supported models with metadata", %{bypass: bypass, config: config} do
Bypass.expect_once(bypass, "GET", "/api/v1/get_server_capabilities", fn conn ->
    conn
    |> Plug.Conn.put_resp_content_type("application/json")
    |> Plug.Conn.resp(200, ~s({
    "supported_models": [
        {"model_name": "llama", "arch": "llama", "model_id": "llama-3-8b"},
        {"model_name": "qwen", "arch": "qwen"}
    ]
    }))
end)

assert {:ok, %GetServerCapabilitiesResponse{} = resp} =
            Service.get_server_capabilities(config: config)

assert length(resp.supported_models) == 2

[llama, qwen] = resp.supported_models
assert %SupportedModel{model_name: "llama", arch: "llama", model_id: "llama-3-8b"} = llama
assert %SupportedModel{model_name: "qwen", arch: "qwen"} = qwen
end

Phase 4: Property-Based Tests

Create test/tinkex/types/supported_model_prop_test.exs:

defmodule Tinkex.Types.SupportedModelPropTest do
use ExUnit.Case, async: true
use ExUnitProperties

alias Tinkex.Types.SupportedModel

property "from_json always returns a SupportedModel struct" do
    check all json <- json_map_generator() do
    result = SupportedModel.from_json(json)
    assert %SupportedModel{} = result
    end
end

property "model_name is preserved if present" do
    check all name <- string(:alphanumeric, min_length: 1) do
    json = %{"model_name" => name}
    model = SupportedModel.from_json(json)
    assert model.model_name == name
    end
end

defp json_map_generator do
    gen all pairs <- list_of(tuple({string(:alphanumeric), term_generator()})) do
    Map.new(pairs)
    end
end

defp term_generator do
    one_of([
    integer(),
    float(),
    string(:alphanumeric),
    constant(nil),
    list_of(string(:alphanumeric))
    ])
end
end

Implementation Details

Known Fields for SupportedModel

Based on API analysis, these fields should be present (at minimum):
- model_name - Display name (e.g., "meta-llama/Meta-Llama-3-8B")
- model_id - Short identifier (e.g., "llama-3-8b")
- arch - Architecture type (e.g., "llama", "qwen2")

Forward Compatibility
- Python: add typed fields and ensure the response_model emits them; consider allowing extras for future fields.
- Elixir: parse known fields and ignore unknowns gracefully (do not crash or drop known fields).

Backward Compatibility

The parser handles both:
1. Object format: {"model_name": "llama", "arch": "llama"}
2. String format: "llama" (legacy, creates %SupportedModel{model_name: "llama"})

Convenience Helper

Add a model_names/1 function to easily get just the names (for callers who only need that):

@spec model_names(t()) :: [String.t()]
def model_names(%__MODULE__{supported_models: models}) do
Enum.map(models, & &1.model_name)
end

Files to Create

lib/tinkex/types/supported_model.ex
test/tinkex/types/supported_model_test.exs
test/tinkex/types/supported_model_prop_test.exs  # Optional

Files to Modify

lib/tinkex/types/get_server_capabilities_response.ex
test/tinkex/types/get_server_capabilities_response_test.exs  # Create if doesn't exist
test/tinkex/api/service_test.exs

Success Criteria

1. ✅ All new tests pass
2. ✅ SupportedModel struct preserves all known fields
3. ✅ GetServerCapabilitiesResponse.supported_models is [SupportedModel.t()]
4. ✅ Backward compatible with string-only format
5. ✅ model_names/1 helper for easy migration
6. ✅ Property tests verify robustness
7. ✅ Existing tests updated and passing

Commands

# Run type tests
mix test test/tinkex/types/supported_model_test.exs
mix test test/tinkex/types/get_server_capabilities_response_test.exs

# Run service test
mix test test/tinkex/api/service_test.exs

# Run all tests
mix test

# Format code
mix format

# Compile with warnings
mix compile --warnings-as-errors

Do NOT:

- Remove the supported_models field or change it to optional
- Break existing code that accesses response.supported_models
- Reintroduce field loss on the Python side (ensure response_model emits model_id/arch)
- Forget to handle atom keys in from_json/1
- Create circular dependencies between type modules
