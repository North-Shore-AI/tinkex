Agent Prompt: Implement File Upload & Multipart Support for Tinkex (Gap #2)

Overview

You are implementing file upload and multipart/form-data support for the Tinkex (Elixir) SDK. Currently, Tinkex can only send JSON-encoded bodies. The Python SDK has comprehensive file upload support
with automatic multipart encoding.

The Problem: Tinkex defaults to JSON bodies and `Content-Type: application/json` (callers can override manually), and while it will pass through raw binaries, there is no automatic detection or encoding for multipart uploads. Missing pieces:
- File path inputs
- Binary file content or IO streams as file parts
- Multipart form-data encoding
- Automatic content-type detection

Required Reading (IN ORDER)

Read these files to understand the problem and solution:

1. Gap Analysis Document

./docs/20251127/gaps_06/02_file_upload_multipart.md
This contains the detailed analysis of what's missing and a TDD implementation plan.

2. Python File Types & Utilities

./tinker/src/tinker/_types.py
Critical types (lines 43-72):
- FileContent - Union of IO[bytes], bytes, PathLike
- FileTypes - FileContent + tuples with filename/content-type
- RequestFiles - Mapping or sequence of file fields
- HttpxFileTypes / HttpxRequestFiles - httpx-compatible versions

./tinker/src/tinker/_files.py
Critical functions:
- is_file_content/1 - Type guard for file content
- to_httpx_files/1 - Sync file transformation
- async_to_httpx_files/1 - Async file transformation
- _transform_file/1 - Convert FileTypes to httpx format
- read_file_content/1 - Read PathLike to bytes

3. Python Base Client Multipart Handling

./tinker/src/tinker/_base_client.py
Search for multipart and files to see:
- Line ~451: files = options.files
- Line ~453-462: Multipart Content-Type handling
- Line ~471: _serialize_multipartform() for form data
- Line ~479-480: ForceMultipartDict() trick for empty files
- Line ~494: kwargs["files"] = files passed to httpx
- Line ~513-518: _serialize_multipartform() implementation

4. Current Elixir API Implementation

./lib/tinkex/api/api.ex
Study:
- prepare_body/2 (lines 276-282) - Only JSON encoding
- build_headers/4 (lines 257-274) - Hardcoded application/json
- post/3 (lines 32-70) - No file support

5. Current Elixir Transform Module

./lib/tinkex/transform.ex
The current transform only handles maps/structs, no file awareness.

The Gap Explained

Python Flow (Full File Support):

# Multiple ways to specify files:
files = {"upload": open("file.txt", "rb")}              # File handle
files = {"upload": b"raw bytes"}                         # Bytes
files = {"upload": Path("file.txt")}                     # PathLike
files = {"upload": ("name.txt", content, "text/plain")} # Tuple with metadata

# In request:
client.post("/upload", files=files)

# Python SDK:
1. to_httpx_files() transforms files to httpx format
2. If files present, switches to multipart/form-data
3. _serialize_multipartform() flattens nested body to form fields
4. httpx generates boundary and encodes multipart body

Elixir Flow (JSON Only):

# Only option:
body = %{data: "some data"}
API.post("/endpoint", body, opts)

# Elixir SDK:
1. Transform.transform(body) - just maps
2. Jason.encode!(body) - JSON only
3. Content-Type: application/json - always
4. ❌ No file support
5. ❌ No multipart encoding

Implementation Requirements

Follow the module/phase breakdown in `02_file_upload_multipart.md` (Types, Reader, AsyncReader, Transform, Multipart FormSerializer/Encoder, API integration). Key building blocks:

New modules (names per gap doc):
- `Tinkex.Files.Types` – file/file tuple guards and validation
- `Tinkex.Files.Reader` – sync file/path/stream reading + filename extraction
- `Tinkex.Files.AsyncReader` – async wrapper (Task) around Reader
- `Tinkex.Files.Transform` – normalize user file inputs to multipart-ready tuples
- `Tinkex.Multipart.FormSerializer` – flatten maps/lists to bracketed form fields
- `Tinkex.Multipart.Encoder` – RFC 7578 multipart body builder + boundary generation
- Finch has no multipart encoder; you must construct the multipart body + boundary before calling `Finch.build/4` and set the `Content-Type` accordingly (or respect a caller-provided boundary header).

TDD Implementation Plan

Use `Supertester.ExUnitFoundation` with isolation helpers for tests that start Finch pools, mock servers, or other processes.

Phase 1: File Type Guards

Create test/tinkex/files/types_test.exs:

defmodule Tinkex.Files.TypesTest do
use ExUnit.Case, async: true

alias Tinkex.Files.Types

describe "file_content?/1" do
    test "returns true for binary" do
    assert Types.file_content?("raw bytes")
    assert Types.file_content?(<<1, 2, 3>>)
    end

    test "returns true for Path struct" do
    assert Types.file_content?(Path.expand("./mix.exs"))
    end

    test "returns false for other types" do
    refute Types.file_content?(%{})
    refute Types.file_content?([1, 2, 3])
    refute Types.file_content?(123)
    end
end

describe "file_types?/1" do
    test "returns true for file_content" do
    assert Types.file_types?("bytes")
    end

    test "returns true for tuple with filename" do
    assert Types.file_types?({"name.txt", "content"})
    end

    test "returns true for tuple with content-type" do
    assert Types.file_types?({"name.txt", "content", "text/plain"})
    end

    test "returns true for tuple with headers" do
    assert Types.file_types?({"name.txt", "content", "text/plain", [{"x-custom", "val"}]})
    end
end
end

Phase 2: File Reader

Create test/tinkex/files/reader_test.exs:

defmodule Tinkex.Files.ReaderTest do
use ExUnit.Case, async: true

alias Tinkex.Files.Reader

describe "read_file_content/1" do
    test "passes through binary" do
    assert {:ok, "hello"} = Reader.read_file_content("hello")
    end

    test "reads file from path" do
    # Create temp file
    path = Path.join(System.tmp_dir!(), "test_#{:rand.uniform(10000)}.txt")
    File.write!(path, "test content")

    assert {:ok, "test content"} = Reader.read_file_content(path)

    File.rm!(path)
    end

    test "returns error for missing file" do
    assert {:error, :enoent} = Reader.read_file_content("/nonexistent/path.txt")
    end
end

describe "extract_filename/1" do
    test "extracts basename from path" do
    assert "file.txt" = Reader.extract_filename("/path/to/file.txt")
    end

    test "extracts from tuple" do
    assert "custom.txt" = Reader.extract_filename({"custom.txt", "content"})
    end

    test "returns nil for binary content" do
    assert nil == Reader.extract_filename("raw bytes")
    end
end
end

Phase 3: Multipart Encoder

Create test/tinkex/multipart/encoder_test.exs:

defmodule Tinkex.Multipart.EncoderTest do
use ExUnit.Case, async: true

alias Tinkex.Multipart.Encoder

describe "generate_boundary/0" do
    test "generates unique boundaries" do
    b1 = Encoder.generate_boundary()
    b2 = Encoder.generate_boundary()

    assert is_binary(b1)
    assert byte_size(b1) >= 16
    assert b1 != b2
    end
end

describe "encode/2" do
    test "encodes single file" do
    files = %{"upload" => "file content"}

    {:ok, body, content_type} = Encoder.encode_multipart(%{}, files)

    assert content_type =~ "multipart/form-data; boundary="
    assert body =~ "Content-Disposition: form-data; name=\"upload\""
    assert body =~ "file content"
    end

    test "encodes file with filename" do
    files = %{"doc" => {"readme.txt", "# README", "text/plain"}}

    {:ok, body, _} = Encoder.encode_multipart(%{}, files)

    assert body =~ "filename=\"readme.txt\""
    assert body =~ "Content-Type: text/plain"
    assert body =~ "# README"
    end

    test "encodes multiple files" do
    files = %{
        "file1" => "content1",
        "file2" => "content2"
    }

    {:ok, body, _} = Encoder.encode_multipart(%{}, files)

    assert body =~ "name=\"file1\""
    assert body =~ "name=\"file2\""
    end

    test "includes form data from body" do
    files = %{"upload" => "file content"}
    body_data = %{description: "A test file"}

    {:ok, body, _} = Encoder.encode_multipart(body_data, files)

    assert body =~ "name=\"description\""
    assert body =~ "A test file"
    end
end
end

Phase 4: Form Serializer

Create test/tinkex/multipart/form_serializer_test.exs:

defmodule Tinkex.Multipart.FormSerializerTest do
use ExUnit.Case, async: true

alias Tinkex.Multipart.FormSerializer

describe "serialize_form_fields/1" do
    test "flattens simple map" do
    assert %{"name" => "value"} = FormSerializer.serialize_form_fields(%{name: "value"})
    end

    test "uses bracket notation for nested maps" do
    result = FormSerializer.serialize_form_fields(%{user: %{name: "Alice", age: 30}})

    assert result["user[name]"] == "Alice"
    assert result["user[age]"] == "30"
    end

    test "uses bracket notation for arrays" do
    result = FormSerializer.serialize_form_fields(%{tags: ["a", "b", "c"]})

    # Python uses brackets array format
    assert result["tags[]"] == ["a", "b", "c"]
    end

    test "handles deeply nested structures" do
    result = FormSerializer.serialize_form_fields(%{
        config: %{
        nested: %{
            deep: "value"
        }
        }
    })

    assert result["config[nested][deep]"] == "value"
    end
end
end

Phase 5: API Integration

Create test/tinkex/api/multipart_test.exs:

defmodule Tinkex.API.MultipartTest do
use ExUnit.Case, async: true

# These tests require mocking or a test server

describe "post/3 with files" do
    @tag :integration
    test "sends multipart request when files provided" do
    # Mock the Finch.request to capture the request
    # Verify Content-Type is multipart/form-data with boundary
    # Verify body is properly encoded
    end

    @tag :integration
    test "falls back to JSON when no files" do
    # Verify Content-Type is application/json
    # Verify body is JSON encoded
    end
end
end

Implementation Details

RFC 7578 Multipart Format

--boundary\r\n
Content-Disposition: form-data; name="field1"\r\n
\r\n
value1\r\n
--boundary\r\n
Content-Disposition: form-data; name="file"; filename="test.txt"\r\n
Content-Type: text/plain\r\n
\r\n
file content here\r\n
--boundary--\r\n

Boundary Generation

def generate_boundary do
:crypto.strong_rand_bytes(16)
|> Base.encode16(case: :lower)
end

Files to Create

lib/tinkex/files/
├── types.ex            # Type guards and specs
├── reader.ex           # Sync file reading utilities
├── async_reader.ex     # Async Task wrapper
└── transform.ex        # File input normalization

lib/tinkex/multipart/
├── encoder.ex          # Multipart encoder
└── form_serializer.ex  # Form field flattening

test/tinkex/files/
├── types_test.exs
├── reader_test.exs
└── async_reader_test.exs

test/tinkex/files/transform_test.exs
test/tinkex/multipart/
├── encoder_test.exs
└── form_serializer_test.exs

Files to Modify

- ./lib/tinkex/api/api.ex - Add multipart detection/encoding + header handling
- ./lib/tinkex/transform.ex - Optional: add file awareness or delegate to file pipeline

Success Criteria

1. ✅ All new tests pass
2. ✅ API.post/3 accepts :files option
3. ✅ Files are encoded as multipart/form-data
4. ✅ Content-Type header includes boundary
5. ✅ Nested body data is flattened to form fields (bracket notation)
6. ✅ Path inputs are read to binary
7. ✅ Filename and content-type from tuples are preserved
8. ✅ JSON requests still work (no files = JSON)
9. ✅ No breaking changes to existing API

Commands

# Run tests
mix test test/tinkex/files/
mix test test/tinkex/multipart/

# Run all tests
mix test

# Format code
mix format

# Check compilation
mix compile --warnings-as-errors

Do NOT:

- Break existing JSON body encoding
- Require files for all POST requests
- Change the public API signature of post/3 (files go in opts)
- Use external dependencies for multipart encoding (stdlib only)
- Skip boundary generation (security concern)
- Forget the final --boundary-- terminator
