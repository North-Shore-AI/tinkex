Agent Prompt: Gap #10 - Asynchronous Convenience Methods

Task Overview

You are implementing missing async convenience methods for Tinkex, an Elixir port of the Tinker Python SDK. The Python SDK provides comprehensive *_async() variants for all client methods. Elixir's
Tinkex has excellent async coverage in RestClient (17 async helpers, incl. *_by_tinker_path aliases) but is missing two critical async variants in ServiceClient that break API consistency and prevent parallel client creation.

This is a low-effort, high-impact gap - only ~40 lines of implementation code needed.

Required Reading

Read these files in order before implementation:

Gap Analysis Document:
- ./docs/20251127/gaps_06/10_async_convenience_methods.md

Python Reference Implementation:
- ./tinker/src/tinker/lib/public_interfaces/service_client.py - Lines 153-199 (create_lora_training_client and create_lora_training_client_async)
- ./tinker/src/tinker/lib/public_interfaces/service_client.py - Lines 222-257 (create_training_client_from_state and create_training_client_from_state_async)
- ./tinker/src/tinker/lib/public_interfaces/rest_client.py - Coverage of async wrappers (14 entry points; `get_weights_info_by_tinker_path` is already awaitable via APIFuture)

Elixir Current Implementation:
- ./lib/tinkex/service_client.ex - Current ServiceClient (has get_server_capabilities_async and create_sampling_client_async, but missing other async variants)
- ./lib/tinkex/rest_client.ex - Example of full async coverage (17 async helpers)
- ./lib/tinkex/training_client.ex - Heavy ops return Tasks already; `get_info/1` is sync-only

Gap Explanation

Python Dual API Pattern:

# Every method has both sync and async variants
class ServiceClient:
    def create_lora_training_client(self, base_model, rank=32, ...):
        """Synchronous - blocks until complete."""
        return self._create_lora_training_client_submit(...).result()

    async def create_lora_training_client_async(self, base_model, rank=32, ...):
        """Asynchronous - returns awaitable."""
        return await self._create_lora_training_client_submit(...)

    def create_training_client_from_state(self, path, ...):
        """Synchronous - blocks until complete."""
        return self._create_training_client_from_state_submit(...).result()

    async def create_training_client_from_state_async(self, path, ...):
        """Asynchronous - returns awaitable."""
        return await self._create_training_client_from_state_submit(...)

Elixir Current ServiceClient:

defmodule Tinkex.ServiceClient do
# ✅ HAS async variant
def get_server_capabilities(service_client), do: ...
def get_server_capabilities_async(service_client), do: Task.async(...)

# ✅ HAS async variant
def create_sampling_client(service_client, opts), do: ...
def create_sampling_client_async(service_client, opts), do: Task.async(...)

# ❌ MISSING async variant
def create_lora_training_client(service_client, base_model, opts), do: ...
# def create_lora_training_client_async/3 - DOES NOT EXIST

# ❌ MISSING async variant
def create_training_client_from_state(service_client, path, opts), do: ...
# def create_training_client_from_state_async/3 - DOES NOT EXIST
end

Impact of Missing Methods:

# Cannot do parallel client creation efficiently
tasks = [
ServiceClient.get_server_capabilities_async(service),
ServiceClient.create_sampling_client_async(service, base_model: "model-a"),
# ❌ This doesn't exist:
# ServiceClient.create_lora_training_client_async(service, "model-b", rank: 16)
]
results = Task.await_many(tasks)  # Would be great for initialization!

RestClient Pattern (Already Implemented - Use as Reference):

# Every sync method has an async variant
def list_sessions(client, opts \\ []), do: ...
def list_sessions_async(client, opts \\ []) do
Task.async(fn -> list_sessions(client, opts) end)
end

def get_training_run(client, run_id), do: ...
def get_training_run_async(client, run_id) do
Task.async(fn -> get_training_run(client, run_id) end)
end
# ... plus the other 15 async helpers (17 total, including *_by_tinker_path aliases)

Implementation Requirements

Add Two Async Methods to ServiceClient

File: ./lib/tinkex/service_client.ex

Add after create_sampling_client_async/2 (around line 101):

@doc """
Create a LoRA training client asynchronously.

Returns a Task that resolves to `{:ok, pid()}` or `{:error, reason}`.

## Examples

    task = ServiceClient.create_lora_training_client_async(
    service_pid,
    "meta-llama/Llama-3.1-8B",
    rank: 16
    )
    {:ok, training_pid} = Task.await(task)

    # Parallel creation
    tasks = [
    ServiceClient.create_lora_training_client_async(service, "model-a", rank: 8),
    ServiceClient.create_lora_training_client_async(service, "model-b", rank: 16)
    ]
    results = Task.await_many(tasks)
"""
@spec create_lora_training_client_async(t(), String.t(), keyword()) :: Task.t()
def create_lora_training_client_async(service_client, base_model, opts \\ [])
    when is_binary(base_model) do
Task.async(fn ->
    create_lora_training_client(service_client, base_model, opts)
end)
end

@doc """
Create a training client from saved checkpoint asynchronously.

Returns a Task that resolves to `{:ok, pid()}` or `{:error, reason}`.
The checkpoint's metadata (LoRA config, base model) is fetched automatically.

## Examples

    path = "tinker://run-123/weights/checkpoint-001"
    task = ServiceClient.create_training_client_from_state_async(service_pid, path)
    {:ok, training_pid} = Task.await(task, 60_000)

    # Parallel checkpoint loading
    paths = ["tinker://run-1/weights/ckpt-001", "tinker://run-2/weights/ckpt-001"]
    tasks = Enum.map(paths, fn path ->
    ServiceClient.create_training_client_from_state_async(service, path)
    end)
    results = Task.await_many(tasks, :infinity)
"""
@spec create_training_client_from_state_async(t(), String.t(), keyword()) :: Task.t()
def create_training_client_from_state_async(service_client, path, opts \\ [])
    when is_binary(path) do
Task.async(fn ->
    create_training_client_from_state(service_client, path, opts)
end)
end

TDD Implementation Plan

Test File: test/tinkex/service_client_async_test.exs

defmodule Tinkex.ServiceClientAsyncTest do
use ExUnit.Case, async: true

alias Tinkex.ServiceClient
alias Tinkex.Error

# These tests use mocks - for full integration tests, see integration suite

describe "create_lora_training_client_async/3" do
    setup do
    # Start a mock service client
    {:ok, service} = start_mock_service_client()
    {:ok, service: service}
    end

    test "returns a Task", %{service: service} do
    task = ServiceClient.create_lora_training_client_async(
        service,
        "test-model",
        rank: 16
    )

    assert %Task{} = task
    end

    test "Task resolves to {:ok, pid} on success", %{service: service} do
    task = ServiceClient.create_lora_training_client_async(
        service,
        "test-model",
        rank: 16
    )

    result = Task.await(task, 5_000)

    assert {:ok, pid} = result
    assert is_pid(pid)
    end

    test "Task resolves to {:error, reason} on failure", %{service: service} do
    # Configure mock to fail
    set_mock_to_fail(service, :create_training_client)

    task = ServiceClient.create_lora_training_client_async(
        service,
        "invalid-model",
        rank: 16
    )

    result = Task.await(task, 5_000)

    assert {:error, %Error{}} = result
    end

    test "passes options through correctly", %{service: service} do
    task = ServiceClient.create_lora_training_client_async(
        service,
        "test-model",
        rank: 32,
        seed: 42,
        train_mlp: true
    )

    {:ok, pid} = Task.await(task, 5_000)

    # Verify options were passed
    info = get_training_client_info(pid)
    assert info.lora_config.rank == 32
    assert info.lora_config.seed == 42
    assert info.lora_config.train_mlp == true
    end

    test "allows parallel creation of multiple clients", %{service: service} do
    tasks = [
        ServiceClient.create_lora_training_client_async(service, "model-a", rank: 8),
        ServiceClient.create_lora_training_client_async(service, "model-b", rank: 16),
        ServiceClient.create_lora_training_client_async(service, "model-c", rank: 32)
    ]

    results = Task.await_many(tasks, 10_000)

    assert length(results) == 3
    assert Enum.all?(results, &match?({:ok, pid} when is_pid(pid), &1))

    # Verify all pids are different
    pids = Enum.map(results, fn {:ok, pid} -> pid end)
    assert length(Enum.uniq(pids)) == 3
    end

    test "requires base_model to be a binary", %{service: service} do
    assert_raise FunctionClauseError, fn ->
        ServiceClient.create_lora_training_client_async(service, 123, rank: 16)
    end
    end
end

describe "create_training_client_from_state_async/3" do
    setup do
    {:ok, service} = start_mock_service_client()
    {:ok, service: service}
    end

    test "returns a Task", %{service: service} do
    task = ServiceClient.create_training_client_from_state_async(
        service,
        "tinker://run-123/weights/ckpt-001"
    )

    assert %Task{} = task
    end

    test "Task resolves to {:ok, pid} on success", %{service: service} do
    # Setup mock checkpoint
    setup_mock_checkpoint(service, "tinker://run-123/weights/ckpt-001")

    task = ServiceClient.create_training_client_from_state_async(
        service,
        "tinker://run-123/weights/ckpt-001"
    )

    result = Task.await(task, 10_000)

    assert {:ok, pid} = result
    assert is_pid(pid)
    end

    test "Task resolves to {:error, reason} for invalid path", %{service: service} do
    task = ServiceClient.create_training_client_from_state_async(
        service,
        "tinker://invalid/path"
    )

    result = Task.await(task, 5_000)

    assert {:error, %Error{}} = result
    end

    test "supports load_optimizer option", %{service: service} do
    setup_mock_checkpoint(service, "tinker://run-123/weights/ckpt-001")

    task = ServiceClient.create_training_client_from_state_async(
        service,
        "tinker://run-123/weights/ckpt-001",
        load_optimizer: true
    )

    result = Task.await(task, 10_000)

    assert {:ok, _pid} = result
    end

    test "allows parallel loading of multiple checkpoints", %{service: service} do
    # Setup multiple mock checkpoints
    paths = [
        "tinker://run-1/weights/ckpt-001",
        "tinker://run-2/weights/ckpt-001",
        "tinker://run-3/weights/ckpt-001"
    ]
    Enum.each(paths, &setup_mock_checkpoint(service, &1))

    tasks = Enum.map(paths, fn path ->
        ServiceClient.create_training_client_from_state_async(service, path)
    end)

    results = Task.await_many(tasks, 30_000)

    assert length(results) == 3
    assert Enum.all?(results, &match?({:ok, _}, &1))
    end

    test "requires path to be a binary", %{service: service} do
    assert_raise FunctionClauseError, fn ->
        ServiceClient.create_training_client_from_state_async(service, :not_a_string)
    end
    end
end

describe "parallel operations with mixed async methods" do
    setup do
    {:ok, service} = start_mock_service_client()
    setup_mock_checkpoint(service, "tinker://run-123/weights/ckpt-001")
    {:ok, service: service}
    end

    test "can mix different async operations", %{service: service} do
    tasks = [
        ServiceClient.get_server_capabilities_async(service),
        ServiceClient.create_sampling_client_async(service, base_model: "model-a"),
        ServiceClient.create_lora_training_client_async(service, "model-b", rank: 16),
        ServiceClient.create_training_client_from_state_async(
        service,
        "tinker://run-123/weights/ckpt-001"
        )
    ]

    results = Task.await_many(tasks, 30_000)

    assert length(results) == 4

    [capabilities, sampling, training, restored] = results

    assert {:ok, %Tinkex.Types.GetServerCapabilitiesResponse{}} = capabilities
    assert {:ok, sampling_pid} = sampling
    assert {:ok, training_pid} = training
    assert {:ok, restored_pid} = restored

    assert is_pid(sampling_pid)
    assert is_pid(training_pid)
    assert is_pid(restored_pid)
    end

    test "handles mixed success and failure in parallel", %{service: service} do
    tasks = [
        ServiceClient.create_lora_training_client_async(service, "valid-model", rank: 16),
        ServiceClient.create_training_client_from_state_async(service, "tinker://invalid/path"),
        ServiceClient.create_sampling_client_async(service, base_model: "valid-model")
    ]

    results = Task.await_many(tasks, 10_000)

    assert length(results) == 3

    [training, restored, sampling] = results

    assert {:ok, _} = training
    assert {:error, _} = restored  # Invalid path
    assert {:ok, _} = sampling
    end
end

describe "Task behavior" do
    setup do
    {:ok, service} = start_mock_service_client()
    {:ok, service: service}
    end

    test "Task can be yielded with timeout", %{service: service} do
    task = ServiceClient.create_lora_training_client_async(
        service,
        "test-model",
        rank: 16
    )

    # Use yield instead of await for timeout control
    case Task.yield(task, 5_000) do
        {:ok, {:ok, pid}} ->
        assert is_pid(pid)

        {:ok, {:error, _}} ->
        flunk("Unexpected error")

        nil ->
        Task.shutdown(task)
        flunk("Task timed out")
    end
    end

    test "Task can be shutdown if no longer needed", %{service: service} do
    task = ServiceClient.create_lora_training_client_async(
        service,
        "test-model",
        rank: 16
    )

    # Immediately shutdown - don't wait for result
    result = Task.shutdown(task, :brutal_kill)

    # Task was either completed or killed
    assert result in [nil, {:ok, {:ok, _}}, {:ok, {:error, _}}]
    end
end

# Helper functions for test setup
defp start_mock_service_client do
    # Implementation depends on test infrastructure
    # Could use Mox or start actual ServiceClient with mock config
    Tinkex.ServiceClient.start_link(config: test_config())
end

defp test_config do
    Tinkex.Config.new(
    api_key: "test-key",
    base_url: "http://localhost:8080"
    )
end

defp set_mock_to_fail(_service, _operation) do
    # Configure mock to fail for specific operation
    :ok
end

defp setup_mock_checkpoint(_service, _path) do
    # Setup mock checkpoint data
    :ok
end

defp get_training_client_info(pid) do
    Tinkex.TrainingClient.get_info(pid)
end
end

Test File: test/tinkex/service_client_async_integration_test.exs

defmodule Tinkex.ServiceClientAsyncIntegrationTest do
use ExUnit.Case

@moduletag :integration
@moduletag timeout: 120_000

alias Tinkex.ServiceClient

describe "integration: parallel client initialization" do
    @tag :live_api
    test "initializes multiple clients in parallel" do
    {:ok, service} = ServiceClient.start_link(config: live_config())

    # Run multiple async operations in parallel
    init_tasks = [
        ServiceClient.get_server_capabilities_async(service),
        ServiceClient.create_sampling_client_async(service, base_model: test_model()),
        ServiceClient.create_lora_training_client_async(service, test_model(), rank: 16)
    ]

    # All should complete successfully
    results = Task.await_many(init_tasks, 60_000)

    assert length(results) == 3
    assert Enum.all?(results, &match?({:ok, _}, &1))
    end
end

describe "integration: checkpoint restoration" do
    @tag :live_api
    test "restores from checkpoint asynchronously" do
    {:ok, service} = ServiceClient.start_link(config: live_config())

    # First create and save a checkpoint
    {:ok, training} = ServiceClient.create_lora_training_client(
        service,
        test_model(),
        rank: 16
    )

    {:ok, save_task} = Tinkex.TrainingClient.save_state(training, "test-checkpoint")
    {:ok, save_result} = Task.await(save_task)

    # Now restore asynchronously
    task = ServiceClient.create_training_client_from_state_async(
        service,
        save_result.tinker_path
    )

    assert %Task{} = task

    {:ok, restored} = Task.await(task, 60_000)
    assert is_pid(restored)

    # Verify restoration
    {:ok, info} = Tinkex.TrainingClient.get_info(restored)
    assert info.model_data.lora_rank == 16
    end
end

defp live_config do
    Tinkex.Config.new()
end

defp test_model do
    System.get_env("TINKEX_TEST_MODEL", "Qwen/Qwen2.5-0.5B")
end
end

Success Criteria

1. New Async Methods Tests Pass
- create_lora_training_client_async/3 returns Task.t()
- Task resolves to {:ok, pid} or {:error, reason}
- Options are passed through correctly
- Guard clause enforces base_model is binary
2. Checkpoint Async Tests Pass
- create_training_client_from_state_async/3 returns Task.t()
- Task resolves correctly with loaded weights
- load_optimizer option works
- Guard clause enforces path is binary
3. Parallel Operations Tests Pass
- Multiple async calls can run concurrently
- Task.await_many/2 works with mixed operations
- Mixed success/failure handled correctly
4. Task Behavior Tests Pass
- Task.yield/2 works for timeout control
- Task.shutdown/2 can cancel operations
5. API Consistency Achieved
- ServiceClient now has 4 async methods (was 2)
- Pattern matches RestClient's comprehensive coverage (17 async helpers)
- Documentation includes examples for parallel usage
6. All Tests Pass
mix test test/tinkex/service_client_async_test.exs
mix test test/tinkex/service_client_test.exs  # Existing tests still pass
7. Dialyzer Passes
mix dialyzer

Commands to Run

# Run new async tests
mix test test/tinkex/service_client_async_test.exs

# Run all ServiceClient tests (verify no regressions)
mix test test/tinkex/service_client_test.exs

# Run full test suite
mix test

# Check types
mix dialyzer

# Format code
mix format

# Run integration tests (if live API available)
mix test --only integration test/tinkex/service_client_async_integration_test.exs

Implementation Order

1. Red: Write test/tinkex/service_client_async_test.exs - tests fail (functions don't exist)
2. Green: Add create_lora_training_client_async/3 to lib/tinkex/service_client.ex
3. Green: Add create_training_client_from_state_async/3 to lib/tinkex/service_client.ex
4. Refactor: Ensure documentation is comprehensive
5. Run existing ServiceClient tests to verify no regressions
6. Run full test suite
7. Update module documentation with async examples

Documentation Update

Add to @moduledoc in lib/tinkex/service_client.ex:

@moduledoc """
Entry point for Tinkex operations.

## Async Operations

ServiceClient provides async variants for all long-running operations:

    # Synchronous - blocks until complete
    {:ok, training_pid} = ServiceClient.create_lora_training_client(
    service, "model", rank: 16
    )

    # Asynchronous - returns Task immediately
    task = ServiceClient.create_lora_training_client_async(
    service, "model", rank: 16
    )
    {:ok, training_pid} = Task.await(task, 30_000)

Async methods enable efficient parallel initialization:

    tasks = [
    ServiceClient.get_server_capabilities_async(service),
    ServiceClient.create_sampling_client_async(service, base_model: "model-a"),
    ServiceClient.create_lora_training_client_async(service, "model-b", rank: 16),
    ServiceClient.create_training_client_from_state_async(service, checkpoint_path)
    ]
    results = Task.await_many(tasks, 30_000)

## Available Async Methods

- `get_server_capabilities_async/1`
- `create_sampling_client_async/2`
- `create_lora_training_client_async/3`
- `create_training_client_from_state_async/3`
"""

Backward Compatibility Notes

All changes are purely additive:

- No existing function signatures changed
- No existing behavior modified
- New functions follow established naming pattern (*_async)
- Existing code using sync versions continues to work unchanged

Implementation Metrics

- New Lines of Code: ~40 (2 functions + docs)
- New Test Lines: ~300
- Risk Level: Minimal (wrapper functions only)
- Breaking Changes: None
