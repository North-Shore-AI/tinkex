# Tinkex SessionManager Diagnostic Script
#
# Run in IEx connected to a running Tinkex application:
#   iex> c("docs/20251126/ets-session-persistence-vulnerability/DIAGNOSTIC_SCRIPT.exs")
#
# Or evaluate directly:
#   iex> Code.eval_file("docs/20251126/ets-session-persistence-vulnerability/DIAGNOSTIC_SCRIPT.exs")

defmodule Tinkex.Diagnostics do
  @moduledoc """
  Diagnostic utilities for investigating SessionManager ETS state.
  """

  @doc """
  Print a full diagnostic report of SessionManager and ETS state.
  """
  def report do
    IO.puts("\n" <> String.duplicate("=", 60))
    IO.puts("TINKEX SESSIONMANAGER DIAGNOSTIC REPORT")
    IO.puts("Generated: #{DateTime.utc_now()}")
    IO.puts(String.duplicate("=", 60) <> "\n")

    check_ets_table()
    check_http_pool()
    check_session_manager()
    list_sessions()
    find_zombie_sessions()
    find_orphaned_pools()

    IO.puts("\n" <> String.duplicate("=", 60))
    IO.puts("END REPORT")
    IO.puts(String.duplicate("=", 60) <> "\n")
  end

  @doc """
  Check if the ETS table exists and its properties.
  """
  def check_ets_table do
    IO.puts("## ETS Table Status\n")

    case :ets.whereis(:tinkex_sessions) do
      :undefined ->
        IO.puts("  [ERROR] :tinkex_sessions table does not exist")

      ref ->
        info = :ets.info(ref)
        IO.puts("  [OK] :tinkex_sessions exists")
        IO.puts("  - Size: #{info[:size]} entries")
        IO.puts("  - Memory: #{info[:memory]} words")
        IO.puts("  - Owner: #{inspect(info[:owner])}")
        IO.puts("  - Type: #{info[:type]}")
        IO.puts("  - Protection: #{info[:protection]}")
    end

    IO.puts("")
  end

  @doc """
  Check if the default HTTP pool is running.
  """
  def check_http_pool do
    IO.puts("## HTTP Pool Status\n")

    pool = Application.get_env(:tinkex, :http_pool, Tinkex.HTTP.Pool)
    IO.puts("  Configured pool: #{inspect(pool)}")

    case Process.whereis(pool) do
      nil ->
        IO.puts("  [ERROR] Pool #{inspect(pool)} is NOT running")

      pid ->
        IO.puts("  [OK] Pool #{inspect(pool)} is running (#{inspect(pid)})")

        try do
          info = Process.info(pid, [:memory, :message_queue_len, :status])
          IO.puts("  - Memory: #{info[:memory]} bytes")
          IO.puts("  - Message queue: #{info[:message_queue_len]}")
          IO.puts("  - Status: #{info[:status]}")
        rescue
          _ -> IO.puts("  - Could not get process info")
        end
    end

    IO.puts("")
  end

  @doc """
  Check SessionManager process state.
  """
  def check_session_manager do
    IO.puts("## SessionManager Status\n")

    case Process.whereis(Tinkex.SessionManager) do
      nil ->
        IO.puts("  [ERROR] SessionManager is NOT running")

      pid ->
        IO.puts("  [OK] SessionManager is running (#{inspect(pid)})")

        try do
          state = :sys.get_state(pid)
          session_count = map_size(state.sessions || %{})
          IO.puts("  - Sessions in memory: #{session_count}")
          IO.puts("  - Heartbeat interval: #{state.heartbeat_interval_ms}ms")
          IO.puts("  - Warning after: #{state.heartbeat_warning_after_ms}ms")
        rescue
          e -> IO.puts("  - Could not get state: #{inspect(e)}")
        end
    end

    IO.puts("")
  end

  @doc """
  List all sessions with their status.
  """
  def list_sessions do
    IO.puts("## Session List\n")

    sessions = get_ets_sessions()

    if sessions == [] do
      IO.puts("  No sessions in ETS table")
    else
      now_ms = System.monotonic_time(:millisecond)

      Enum.each(sessions, fn {session_id, entry} ->
        age_ms = now_ms - entry.last_success_ms
        pool = entry.config.http_pool
        pool_alive? = Process.whereis(pool) != nil
        has_error? = entry.last_error != nil

        status =
          cond do
            not pool_alive? -> "[DEAD POOL]"
            has_error? and age_ms > 120_000 -> "[ZOMBIE]"
            has_error? -> "[FAILING]"
            true -> "[OK]"
          end

        IO.puts("  #{status} #{session_id}")
        IO.puts("      pool: #{inspect(pool)} (alive: #{pool_alive?})")
        IO.puts("      base_url: #{entry.config.base_url}")
        IO.puts("      last_success: #{age_ms}ms ago")

        if has_error? do
          IO.puts("      last_error: #{inspect(entry.last_error)}")
        end
      end)
    end

    IO.puts("")
  end

  @doc """
  Find sessions that are failing for >120s (zombies).
  """
  def find_zombie_sessions do
    IO.puts("## Zombie Sessions (failing >120s)\n")

    zombies =
      get_ets_sessions()
      |> Enum.filter(fn {_id, entry} ->
        now_ms = System.monotonic_time(:millisecond)
        entry.last_error != nil and now_ms - entry.last_success_ms > 120_000
      end)

    if zombies == [] do
      IO.puts("  [OK] No zombie sessions found")
    else
      IO.puts("  [WARNING] Found #{length(zombies)} zombie session(s):")

      Enum.each(zombies, fn {session_id, entry} ->
        now_ms = System.monotonic_time(:millisecond)
        failing_for = now_ms - entry.last_success_ms
        IO.puts("    - #{session_id} (failing for #{div(failing_for, 1000)}s)")
      end)
    end

    IO.puts("")
  end

  @doc """
  Find sessions referencing pools that don't exist.
  """
  def find_orphaned_pools do
    IO.puts("## Orphaned Pool References\n")

    orphaned =
      get_ets_sessions()
      |> Enum.filter(fn {_id, entry} ->
        Process.whereis(entry.config.http_pool) == nil
      end)

    if orphaned == [] do
      IO.puts("  [OK] All sessions reference live pools")
    else
      IO.puts("  [ERROR] Found #{length(orphaned)} session(s) with dead pool references:")

      Enum.each(orphaned, fn {session_id, entry} ->
        IO.puts("    - #{session_id} -> #{inspect(entry.config.http_pool)}")
      end)
    end

    IO.puts("")
  end

  @doc """
  Clean up zombie sessions (interactive).
  """
  def cleanup_zombies do
    zombies =
      get_ets_sessions()
      |> Enum.filter(fn {_id, entry} ->
        now_ms = System.monotonic_time(:millisecond)
        entry.last_error != nil and now_ms - entry.last_success_ms > 120_000
      end)

    if zombies == [] do
      IO.puts("No zombie sessions to clean up")
    else
      IO.puts("Found #{length(zombies)} zombie sessions:")
      Enum.each(zombies, fn {id, _} -> IO.puts("  - #{id}") end)

      IO.puts("\nDelete these sessions? (y/n)")
      response = IO.gets("") |> String.trim() |> String.downcase()

      if response == "y" do
        Enum.each(zombies, fn {id, _} ->
          :ets.delete(:tinkex_sessions, id)
          IO.puts("Deleted: #{id}")
        end)

        IO.puts("\nRestarting SessionManager to clear memory state...")
        # Note: This requires SessionManager to be supervised
        # GenServer.stop(Tinkex.SessionManager)
        IO.puts("Done. SessionManager should reload from cleaned ETS.")
      else
        IO.puts("Aborted")
      end
    end
  end

  @doc """
  Clean up sessions with dead pool references (interactive).
  """
  def cleanup_orphaned do
    orphaned =
      get_ets_sessions()
      |> Enum.filter(fn {_id, entry} ->
        Process.whereis(entry.config.http_pool) == nil
      end)

    if orphaned == [] do
      IO.puts("No orphaned sessions to clean up")
    else
      IO.puts("Found #{length(orphaned)} orphaned sessions:")

      Enum.each(orphaned, fn {id, entry} ->
        IO.puts("  - #{id} -> #{inspect(entry.config.http_pool)}")
      end)

      IO.puts("\nDelete these sessions? (y/n)")
      response = IO.gets("") |> String.trim() |> String.downcase()

      if response == "y" do
        Enum.each(orphaned, fn {id, _} ->
          :ets.delete(:tinkex_sessions, id)
          IO.puts("Deleted: #{id}")
        end)

        IO.puts("Done.")
      else
        IO.puts("Aborted")
      end
    end
  end

  # Private helpers

  defp get_ets_sessions do
    case :ets.whereis(:tinkex_sessions) do
      :undefined -> []
      _ -> :ets.tab2list(:tinkex_sessions)
    end
  rescue
    ArgumentError -> []
  end
end

# Run the report automatically when script is loaded
IO.puts("\nLoaded Tinkex.Diagnostics module.")
IO.puts("Available functions:")
IO.puts("  Tinkex.Diagnostics.report()          - Full diagnostic report")
IO.puts("  Tinkex.Diagnostics.list_sessions()   - List all sessions")
IO.puts("  Tinkex.Diagnostics.find_zombie_sessions() - Find failing sessions")
IO.puts("  Tinkex.Diagnostics.find_orphaned_pools()  - Find dead pool refs")
IO.puts("  Tinkex.Diagnostics.cleanup_zombies()      - Interactive cleanup")
IO.puts("  Tinkex.Diagnostics.cleanup_orphaned()     - Interactive cleanup")
IO.puts("")
